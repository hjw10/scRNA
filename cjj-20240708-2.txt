#写在前面的话：对照是Model,药物是Treatment
cellranger count --id=m-out \
--fastqs=/public/workspace/lincs/me/yao/Model/ \
--sample=Model \
--transcriptome=/public/workspace/lincs/lab7/singlecell/cellranger/refdata-gex-mm10-2020-A/



Treatment


cellranger count --id=t-out \
--fastqs=/public/workspace/lincs/me/yao/Treatment/ \
--sample=Treatment \
--transcriptome=/public/workspace/lincs/lab7/singlecell/cellranger/refdata-gex-mm10-2020-A/


cd /public/workspace/lincs/lab7/singlecell/velocyto/
singularity shell velocyto_latest.sif
velocyto run10x -m /public/workspace/lincs/lab7/singlecell/velocyto/mm10_rmsk.gtf /public/workspace/lincs/me/yao/m-out/ /public/workspace/lincs/lab7/singlecell/cellranger/refdata-gex-mm10-2020-A/genes/genes.gtf

cd /public/workspace/lincs/lab7/singlecell/velocyto/
singularity shell velocyto_latest.sif
velocyto run10x -m /public/workspace/lincs/lab7/singlecell/velocyto/mm10_rmsk.gtf /public/workspace/lincs/me/yao/t-out/ /public/workspace/lincs/lab7/singlecell/cellranger/refdata-gex-mm10-2020-A/genes/genes.gtf



#####################################################################

#######从这开始
singularity shell /home/server/data1/lab7/soft2/lcs_scRNAseq20240509.sif
R
setwd("/home/server/data1/jyz/Ctrl_EcO/")
###加载所需要的包
library(future)
plan("multiprocess",workers=20)
###future.globals.maxSize= X,x的单位是字节，下面这句代码是8个G
options(future.globals.maxSize= 80000*1024^2) 
library(data.table)
library(Seurat)
library(tidyverse)
library(dplyr)
library(patchwork)
#install.packages("devtools")
#library(devtools)
#install_github("immunogenomics/harmony")
library(harmony)
#BiocManager::install("SingleCellExperiment")
library(SingleCellExperiment)

library(ggplot2)
library(RColorBrewer)

library(viridis)
library(DoubletFinder)
set.seed(123456)
if (!dir.exists("02QC")){
dir.create("02QC")
}
#双细胞函数
seurat_standard_normalize_and_scale <- function(colon, cluster, cluster_resolution){
  # colon is seurat object, 
  colon <- NormalizeData(colon, normalization.method = "LogNormalize", scale.factor = 10000)
  colon <- FindVariableFeatures(colon, selection.method = "vst", nfeatures = 2000)
  all.genes <- rownames(colon)
  colon <- ScaleData(colon, features = all.genes)
  colon <- RunPCA(colon, features = VariableFeatures(object = colon))
  if (cluster){
    colon <- FindNeighbors(colon, dims = 1:20)
    colon <- FindClusters(colon, resolution = cluster_resolution)
  }
  colon <- RunUMAP(colon, dims = 1:20)
  return(colon)
}

make_seurat_object_and_doublet_removal <- function(data_directory, project_name){
  # function for basic seurat based qc and doubletfinder based doublet removal
  colon.data <- Read10X(data.dir = data_directory)
  currentSample <- CreateSeuratObject(counts = colon.data, project = project_name, min.cells = 3, min.features = 200)
  currentSample[["percent.mt"]] <- PercentageFeatureSet(currentSample, pattern = "^mt-")
  #计算核糖体基因比例
  currentSample[["percent.rb"]] <- PercentageFeatureSet(currentSample, pattern = "^Rp[sl]")
  #计算红细胞基因比例
  HB.genes <- rownames(currentSample)[grep("^Hb[^(p)]", rownames(currentSample),ignore.case = T)]

  currentSample[["percent.HB"]]<-PercentageFeatureSet(currentSample, features=HB.genes) 

  # qc plot-pre filtering
  pdf(paste0("02QC/qc_plots_", project_name, "_prefiltered.pdf"))
  print(VlnPlot(currentSample, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3, pt.size = 0.05))
  dev.off()
  pdf(paste0("02QC/qc_plots_", project_name, "_prefiltered_no_points.pdf"))
  print(VlnPlot(currentSample, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3, pt.size = 0))
  dev.off()
  
  # filter everything to 400 unique genes/cell
  minGene=200
  maxGene=6000
  maxUMI=50000
  pctMT=20
  pctHB=1

  ### 数据质控并绘制小提琴图
  currentSample <- subset(currentSample, subset = nCount_RNA < maxUMI & nFeature_RNA > minGene & 
                  nFeature_RNA < maxGene & percent.mt < pctMT & percent.HB < pctHB)
  #currentSample <- subset(currentSample, subset = nFeature_RNA > 300   & percent.mt<20 & nCount_RNA>1000)
  
  # Normalize and make UMAP
  currentSample <- seurat_standard_normalize_and_scale(currentSample, FALSE)
  
  # Run doublet finder
  nExp_poi <- round(0.04*length(currentSample@meta.data$orig.ident)*length(currentSample@meta.data$orig.ident)/10000)  ## Assuming 7.5% doublet formation rate - tailor for your dataset
  seu_colon <- doubletFinder_v3(currentSample, PCs = 1:20, pN = 0.25, pK = 0.09, nExp = nExp_poi, reuse.pANN = FALSE, sct = FALSE)
  print(head(seu_colon@meta.data))
  
  # rename columns
  seu_colon$doublet.class <- seu_colon[[paste0("DF.classifications_0.25_0.09_",nExp_poi)]]
  seu_colon[[paste0("DF.classifications_0.25_0.09_",nExp_poi)]] <- NULL
  pann <- grep(pattern="^pANN", x=names(seu_colon@meta.data), value=TRUE)
  seu_colon$pANN <- seu_colon[[pann]]
  seu_colon[[pann]] <- NULL
  
  # plot pre and post doublet finder results
  pdf(paste0("02QC/UMAP_pre_double_removal", project_name, ".pdf"))
  print(DimPlot(seu_colon, reduction = "umap", group.by = "doublet.class", cols = c("#D51F26", "#272E6A")))
  dev.off()
  seu_colon <- subset(seu_colon, subset = doublet.class != "Doublet")
  pdf(paste0("02QC/UMAP_post_double_removal", project_name, ".pdf"))
  print(DimPlot(seu_colon, reduction = "umap", cols = c("#D51F26")))
  dev.off()
  
  # Remove extra stuff and return filtered Seurat object
  seu_colon <- DietSeurat(seu_colon, counts=TRUE, data=TRUE, scale.data=FALSE, assays="RNA")
  return(seu_colon)
}

#多样本去除双细胞


#setwd("/public/workspace/lincs/me/scRNA-has2/")


data_directory=c("m-out/outs/filtered_feature_bc_matrix/","t-out/outs/filtered_feature_bc_matrix/")

project_name<-c("M","T")

 

samples <- project_name

sample1 <- make_seurat_object_and_doublet_removal(data_directory[1], samples[1])


###  第一种整合方法  ---锚定整合
#seu_list <- list(sample1)
#for (i in 2:length(samples)){
  
#  setwd("F:/hiv/exp/")
  
#  seu_list[i] <- c(seu_list, make_seurat_object_and_doublet_removal(data_directory[i], samples[i]))
#}


###  第二种整合方法  
seu_list <- sample1
for (i in 2:length(samples)){
  
   
  
  sc.i = make_seurat_object_and_doublet_removal(data_directory[i], samples[i])
  seu_list=merge(seu_list,sc.i)
  
}




scRNA_harmony=seu_list
scRNA_harmony  <- NormalizeData(scRNA_harmony ) %>% FindVariableFeatures() %>% ScaleData() %>% RunPCA(verbose=FALSE)
library(harmony)
scRNA_harmony <- RunHarmony(scRNA_harmony, group.by.vars = "orig.ident")
###问题 harmony之后的数据在哪里？


###一定要指定harmony
scRNA_harmony <- FindNeighbors(scRNA_harmony, reduction = "harmony", dims = 1:40) %>% FindClusters(resolution =1)

scRNA_harmony <- RunUMAP(scRNA_harmony, reduction = "harmony", dims = 1:40)
pdf("02QC/UMAP_scRNA_harmony.pdf")
DimPlot(scRNA_harmony , reduction = "umap",label = T) 
dev.off()
pdf("02QC/UMAP_scRNA_harmony_orig.ident.pdf")
DimPlot(scRNA_harmony, reduction = "umap", split.by ='orig.ident')
dev.off()
#运行时发现没有group，下面3行命令不要运行
pdf("02QC/UMAP_scRNA_harmony_group.pdf")
DimPlot(scRNA_harmony, reduction = "umap", split.by ='group',label = T)
dev.off()
pdf("02QC/UMAP_scRNA_harmony_orig.ident2.pdf")
DimPlot(scRNA_harmony, reduction = "umap", group.by='orig.ident')
dev.off()
table(scRNA_harmony$orig.ident)  

scRNA_harmony_raw<-scRNA_harmony
if (!dir.exists("01RDada")){
dir.create("01RDada")
}

if (!file.exists("01RDada/01_scRNA_harmony_raw.RData")){
save(scRNA_harmony_raw,file="01RDada/01_scRNA_harmony_raw.RData")
}

#######################################################################################

markers <- FindAllMarkers(object = scRNA_harmony, 
                           only.pos = TRUE,
                           logfc.threshold = 0.25)   
 
DefaultAssay(scRNA_harmony) <- "RNA" 
##注：虽然这个函数的默认设置是从 "RNA "插槽中获取数据，但我们鼓励你运行上面的这行代码，
##以防止在分析的上游某处改变了默认分析。原始计数和归一化计数都存储在这个位置中，用于查找标记的函数将自动提取原始计数。 
 
#install.packages('BiocManager')
#BiocManager::install('multtest')
#install.packages('metap')
 
#colnames(scRNA_harmony@meta.data)
#marker2= FindConservedMarkers(scRNA_harmony,
#                      ident.1 = 1,
#                      grouping.var = "orig.ident",
#                      only.pos = TRUE,
#                      min.diff.pct = 0.25,
#                      min.pct = 0.25,
#                      logfc.threshold = 0.25)
 
#############################################################################################03差异基因


####单细胞转录组基础分析四：细胞类型鉴定 ####
#####如果你还想关了rstudio休息 那你就要按照这节课的开头继续设置路径、加载r包、加载数据
####一定记住 每次打开rstudio时候要先设置路径，然后加载r包，最后加数据
####细胞类型的注释一般有三种方法.1、利用marker基因查找网站进行注释  2、使用singler进行注释 3、根据已有的生物学知识或者文献，按照dotplot来注释。
##现在使用方法一寻找marker基因使用网站注释 找marker基因有以下方法三选一，建议第一种
#默认wilcox方法

##3 %>% 这是通道函数 起传递左右  可以自己百度深入理解一下，我这里只告诉你他是起传递作用的

all.markers = markers %>% select(gene, everything()) %>% subset(p_val<0.05)
top10 = all.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_log2FC)
top10_7<-top10 %>% select(cluster=7)
###将marker基因保存一下
if (!dir.exists("03DEG")){
dir.create("03DEG")
}

write.csv(all.markers, "03DEG/diff_genes_wilcox.csv", row.names = F)
###把top10marker基因保存一下
write.csv(top10, "03DEG/top10_diff_genes_wilcox.csv", row.names = F)

##top10基因绘制热图
top10_genes = CaseMatch(search = as.vector(top10$gene), match = rownames(scRNA_harmony)) 
##把marker基因用热图展示出来
plot1 = DoHeatmap(scRNA_harmony, features = top10_genes, group.by = "seurat_clusters", group.bar = T, size = 4)

ggsave("03DEG/top8_markers.pdf", plot=plot1, width=8, height=6) 

#############################################################################################04singleR
##CellMarker：http://biocc.hrbmu.edu.cn/CellMarker/index.jsp
###PanglaoDB：https://panglaodb.se/index.html
####把每一类的marker基因输入到这两个网站中，然后看网站给出的细胞注释信息
##选择基因作图展示-----文章中某些图需要
#挑选部分基因
#select_genes <- c('COL2A1',"PTPRC","EPCAM")
#vlnplot展示
#p1 <- VlnPlot(scRNA_harmony, features = select_genes, pt.size=0, group.by="celltype", ncol=2)
#p1
#ggsave("selectgenes_VlnPlot.png", p1, width=6 ,height=8)
#featureplot展示
#p2 <- FeaturePlot(scRNA_harmony, features = select_genes, reduction = "tsne", label=T, ncol=2)
#p2
#ggsave("selectgenes_FeaturePlot.png", p2, width=8 ,height=12)
#p3=p1|p2
#p3
#ggsave("selectgenes.png", p3, width=10 ,height=8)

#第二种方法用SingleR鉴定细胞类型
#BiocManager::install("SingleR")
library(SingleR)
###下载好数据库后，把ref_Human_all.Rdata加载到环境中，这样算是对数据库的加载，就可以按照singler的算法来对细胞亚群进行定义了。
load("ref_Mouse_all.RData")
###我们可以看到在环境中多了一个叫ref_Human_all的文件 大小为113mb  这个就是数据库
####然后我们把环境中的ref_Human_all赋值与refdata
refdata <- ref_Mouse
###把rna的转录表达数据提取

testdata <- GetAssayData(scRNA_harmony, slot="data")
###把scRNA数据中的seurat_clusters提取出来，注意这里是因子类型的
clusters <- scRNA_harmony@meta.data$seurat_clusters
###开始用singler分析
cellpred <- SingleR(test = testdata, ref = refdata, labels = refdata$label.main, 
                    method = "cluster", clusters = clusters, 
                    assay.type.test = "logcounts", assay.type.ref = "logcounts")
###制作细胞类型的注释文件
celltype = data.frame(ClusterID=rownames(cellpred), celltype=cellpred$labels, stringsAsFactors = FALSE)
###保存一下
if (!dir.exists("04singleR")){
dir.create("04singleR")
}
write.csv(celltype,"04singleR/celltype_singleR.csv",row.names = FALSE)
##把singler的注释写到metadata中 有两种方法
###方法一----没有用
#scRNA1@meta.data$celltype = "NA"
#for(i in 1:nrow(celltype)){
#  scRNA1@meta.data[which(scRNA1@meta.data$seurat_clusters == celltype$ClusterID[i]),'celltype'] <- celltype$celltype[i]}
###因为我把singler的注释加载到metadata中时候，命名的名字叫celltype，所以画图时候，group.by="celltype"
#DimPlot(scRNA1, group.by="celltype", label=T, label.size=5, reduction='tsne')
###方法二：-----用的此方法
celltype = data.frame(ClusterID=rownames(cellpred), celltype=cellpred$labels, stringsAsFactors = F) 
scRNA_harmony@meta.data$singleR=celltype[match(clusters,celltype$ClusterID),'celltype']
###因为我把singler的注释加载到metadata中时候，命名的名字叫singleR，所以画图时候，group.by="singleR"
#DimPlot(scRNA_harmony, group.by="singleR", label=T, label.size=5, reduction='tsne')
###我们可以看到  两种方法得到的结果都是一样的，但是我比较喜欢第二种方法
p<-DimPlot(scRNA_harmony, group.by="singleR", label=T, label.size=3.5, reduction='umap',split.by="orig.ident")
ggsave("04singleR/umap_celltype_singler.pdf", p, width=30 ,height=6)

p<-DimPlot(scRNA_harmony, group.by="singleR", label=T, label.size=3.5, reduction='umap')
ggsave("04singleR/umap_celltype_singler_all.pdf", p, width=10 ,height=6)


##########################################################################05HCL包注释
library(scMCA)
if (!dir.exists("05scMCA")){
dir.create("05scMCA")
}
hcl_result <- scMCA(scdata = scRNA_harmony@assays$RNA@data, numbers_plot = 3)
save(hcl_result,file="05scMCA/01scRNA_harmony_scMCA.RData")
scRNA_harmony@meta.data$scMCA<-as.factor(hcl_result$scMCA)

p<-DimPlot(scRNA_harmony, group.by="scMCA", label=T, label.size=3.5, reduction='umap')
####由于注释的细胞类型很多，图片大小需要调整，并且加入limitsize = FALSE参数，要不然会报错
ggsave("05scMCA/01umap_celltype_scMCA2.pdf", p, width=120 ,height=10,limitsize = FALSE)
#结合scMCA结果，修改singleR注释结果，修改celltype
save.image(file="20231222.RData")
p<-FeaturePlot(scRNA_harmony, features = c("Il33"), split.by = "orig.ident")
ggsave("IL33-umap_celltype_group.pdf", p, width=10,height=6)

p<-DimPlot(scRNA_harmony, group.by="scMCA", label=T, label.size=3.5, reduction='umap')
####由于注释的细胞类型很多，图片大小需要调整，并且加入limitsize = FALSE参数，要不然会报错
ggsave("05scMCA/01umap_celltype_scMCA3.pdf", p, width=120 ,height=30,limitsize = FALSE)
##########
#结合scHCL结果，修改singleR注释结果，修改celltype，

打开04singleR/celltype_singleR.csv，用excel打开，新建一列celltypenew,每一簇细胞进行细致注释。


######复制excel中内容，新建一个文件singleR-scMCA.txt
####################################################，放在05scMCA下
ClusterID	celltype	celltypenew
0	B cells	B cells
1	Macrophages	Macrophages
2	Endothelial cells	Endothelial cells
3	T cells	T cells
4	Fibroblasts	Stromal cells
5	Macrophages	Macrophages
6	Macrophages	Epithelial cells
7	Fibroblasts	Stromal cells
8	T cells	T cells
9	Monocytes	Monocytes
10	Granulocytes	Granulocytes
11	Granulocytes	Granulocytes
12	Fibroblasts	Stromal cells
13	B cells	B cells
14	T cells	Stem and progenitor cells
15	T cells	T cells
16	B cells	B cells
17	NK cells	NK cells
18	Macrophages	Macrophages
19	Fibroblasts	Smooth muscle cells
20	Macrophages	Macrophages
21	Monocytes	dendritic cells
22	Granulocytes	Granulocytes
23	Macrophages	dendritic cells
24	B cells	B cells
25	Macrophages	Macrophages
26	Monocytes	dendritic cells
27	Macrophages	Macrophages
28	Macrophages	Stromal cells
29	Endothelial cells	Endothelial cells
30	B cells	B cells
31	Macrophages	Epithelial cells
32	Macrophages	Adipocytes
33	B cells	Dendritic cells
########################################
newname<-read.table("./05scMCA/singleR-scMCA.txt",header=T,sep="\t")
celltype$celltype<-newname$celltypenew




################################################################################下面不用运行
###要加1，不是减一，可以看一下celltype
celltype$celltype[8]="Stromal cells"
celltype$celltype[9]="Stromal cells"
celltype$celltype[12]="Stromal cells"
celltype$celltype[32]="Stromal cells"
celltype$celltype[23]="Stromal cells"
celltype$celltype[34]="Stromal cells"


celltype$celltype[30]="Epithelial cells"
celltype$celltype[14]="Epithelial cells"
celltype$celltype[29]="Epithelial cells"
celltype$celltype[21]="Epithelial cells"


celltype$celltype[36]="Mast cells"

celltype$celltype[22]="Smooth muscle cells"

celltype$celltype[24]="DC"
celltype$celltype[28]="DC"

celltype$celltype[31]="Endothelial cells"
celltype$celltype[35]="adipocyte"

##################################################################################上面不用运行
scRNA_harmony@meta.data$singleRnew=celltype[match(clusters,celltype$ClusterID),'celltype']

##########NPG配色，在加以改造
#E64B35FF  #4DBBD5FF #00A087FF  #3C5488FF
#F39B7FFF  #8491B4FF   #91D1C2FF  #F7B6D2FF
#7E6148FF  #B09C85FF   #BCBD22FF  #E377C2FF


scRNA_harmony<-scRNA_harmony_singler
scRNA_harmony@meta.data$singleRnew[which(scRNA_harmony@meta.data$singleRnew=="Fibroblast")]="Stromal_cell"


scRNA_harmony@meta.data$Annotation<-scRNA_harmony@meta.data$singleRnew
sample_color <- c("#BCBD22FF","#4DBBD5FF","#00A087FF","#91D1C2FF","#F39B7FFF","#F7B6D2FF","#7E6148FF","#E64B35FF","#3C5488FF","#E377C2FF","#8491B4FF","#B09C85FF")


p<-DimPlot(scRNA_harmony, group.by="Annotation", label=T, label.size=3.5, reduction='umap',cols=sample_color)
ggsave("07umap_celltype_singler_new20240621.pdf", p, width=8 ,height=6)
scRNA_harmony@meta.data$group<-scRNA_harmony@meta.data$orig.ident
#group_list<- ifelse(scRNA_harmony@meta.data$group %in% c("ehc1","ehc2","SRR14118395","SRR14118396","SRR14118397","SRR14118398"),"HC","PD") 
scRNA_harmony@meta.data$group<-as.factor(scRNA_harmony@meta.data$group)

p<-DimPlot(scRNA_harmony, group.by="group", label=T, label.size=3.5, reduction='umap')
ggsave("05scMCA/03umap_celltype_group.pdf", p, width=8 ,height=6)





###好了，以上部分为一部分，我们保存一下20240524
scRNA_harmony_singler2<-scRNA_harmony
if (!file.exists("01RDada/06_scRNA_harmony_singler20240621.Rdata")){
save(scRNA_harmony_singler2,file="01RDada/06_scRNA_harmony_singler20240621.Rdata")
rm(scRNA_harmony_singler2)
}
p<-FeaturePlot(scRNA_harmony, features = c("Il33"), split.by = "orig.ident")
ggsave("IL33-umap_celltype_group-2.pdf", p, width=10,height=6)
#20231227上午重新注释
p<-FeaturePlot(scRNA_harmony, features = c("Ikzf1"), split.by = "orig.ident")
ggsave("Ikzf1-umap_celltype_group-2.pdf", p, width=10,height=6)
p<-FeaturePlot(scRNA_harmony, features = c("Jund"), split.by = "orig.ident")
ggsave("Jund-umap_celltype_group-2.pdf", p, width=10,height=6)

p<-FeaturePlot(scRNA_harmony, features = c("Rel"), split.by = "orig.ident")
ggsave("Rel-umap_celltype_group-2.pdf", p, width=10,height=6)

p<-FeaturePlot(scRNA_harmony, features = c("Fosb"), split.by = "orig.ident")
ggsave("Fosb-umap_celltype_group-2.pdf", p, width=10,height=6)
p<-FeaturePlot(scRNA_harmony, features = c("Nr3c2"), split.by = "orig.ident")
ggsave("Nr3c2-umap_celltype_group-2.pdf", p, width=10,height=6)
p<-FeaturePlot(scRNA_harmony, features = c("Nfkb1"), split.by = "orig.ident")
ggsave("Nfkb1-umap_celltype_group-2.pdf", p, width=10,height=6)

p<-FeaturePlot(scRNA_harmony, features = c("Bhlhe41"), split.by = "orig.ident")
ggsave("Bhlhe41-umap_celltype_group-2.pdf", p, width=10,height=6)
p<-FeaturePlot(scRNA_harmony, features = c("Fos"), split.by = "orig.ident")
ggsave("Fos-umap_celltype_group-2.pdf", p, width=10,height=6)
p<-FeaturePlot(scRNA_harmony, features = c("Irf7"), split.by = "orig.ident")
ggsave("Irf7-umap_celltype_group-2.pdf", p, width=10,height=6)


############################################################
a<-scRNA_harmony_singler@meta.data$orig.ident
b=c()
for(i in 1:length(a)){
b[i]=unlist(strsplit(a[i], "\\_"))[1]
}
scRNA_harmony_singler@meta.data$group<-as.factor(b)


















scRNA_harmony<-scRNA_harmony_singler

####20231227下午用scCODE计算两组基质细胞之间的差异基因，
scRNA_harmony_M<-subset(scRNA_harmony,group=="Ctrl")
scRNA_harmony_T<-subset(scRNA_harmony,group=="EcO")

data1<-as.matrix(scRNA_harmony_M@assays$RNA[,scRNA_harmony_M$singleRnew=="Macrophage"])

data2<-as.matrix(scRNA_harmony_T@assays$RNA[,scRNA_harmony_T$singleRnew=="Macrophage"])

library(scCODE)

results<-scCODE(data2,data1,light = T)
save(results,file="sccode_results20240526.RData")

library(ggplot2)

DE_results<-results$DE_results
DE_results$P_adjust<-as.numeric(DE_results$P_adjust)
p<-FeaturePlot(scRNA_harmony, features = c("CCL5"), split.by = "group")
ggsave("CCL5-control-eco-umap_celltype_group-2.pdf", p, width=12,height=6)

scRNA_harmony_singler<-scRNA_harmony
if (!file.exists("01RDada/05_scRNA_harmony_singler20240526.Rdata")){
save(scRNA_harmony_singler,file="01RDada/02_scRNA_harmony_singler20240526.Rdata")
rm(scRNA_harmony_singler)
}
##################以后就直接调用这个数据   01RDada/05_scRNA_harmony_singler20240526.Rdata


########06-2 由于seurat默认的差异基因图不太美观，因此我们需要重新画一些能发表的图，
#01.marker展示_聚类和热图组合
if (!dir.exists("06-2pictures")){
dir.create("06-2pictures")
}
library(Seurat)
library(tidyverse)
#library(xlsx)
library(harmony)

### 本系列代码由公众号【TOP生物信息】原创

### 找差异基因 #################################################################
load("01RDada/05_scRNA_harmony_singler20240526.Rdata")
testseu<-scRNA_harmony_singler
testseu@meta.data$celltype<-testseu@meta.data$singleRnew
testseu@meta.data$celltype=factor(testseu@meta.data$celltype,
                                  levels = sort(unique(as.character(testseu@meta.data$celltype))))
Idents(testseu)="celltype"
markers_celltype=FindAllMarkers(testseu,logfc.threshold = 0.5,min.pct = 0.1,only.pos = T,test.use = "wilcox")
markers_celltype=markers_celltype%>%filter(p_val_adj < 0.01)
markers_celltype$d=markers_celltype$pct.1 - markers_celltype$pct.2
markers_celltype=markers_celltype%>%filter(d > 0.4)
markers_celltype=markers_celltype%>%arrange(cluster,desc(avg_log2FC))
markers_celltype=as.data.frame(markers_celltype)

### 层次聚类 ###################################################################
# 这一步用的全局的基因
gene_exp_cellnum=rowSums(testseu[["RNA"]]@counts > 0)
gene.keep=gene_exp_cellnum[gene_exp_cellnum > 10]
AveExp=AverageExpression(testseu,assays = "RNA",group.by = "celltype",slot = "data")
AveExp=AveExp$RNA
AveExp=AveExp[names(gene.keep),]

dd <- dist(scale(t(AveExp)), method = "euclidean")
hc <- hclust(dd, method = "ward.D2")

library(ggdendro)
pa=ggdendrogram(hc,theme_dendro = FALSE)+
  theme_minimal()+
  theme(
    panel.grid = element_blank(),
    axis.title.x.bottom = element_blank(),
    axis.title.y.left = element_blank(),
    axis.text.y.left = element_blank(),
    axis.text.x.bottom = element_blank()
  )

dend <- as.dendrogram(hc)
dend_data <- dendro_data(dend, type = "rectangle")
celltype_sort=dend_data$labels$label #聚类图从左到右的细胞顺序

### 圆点绘制 ###################################################################
point_data=as.data.frame(table(testseu@meta.data$celltype))
colnames(point_data)=c("celltype","cellnum")
point_data$celltype=factor(point_data$celltype,levels = celltype_sort) #设置上述的顺序

library(RColorBrewer)
library(scales)
# 配色，按照自己的需求更改
# 如果不会R语言配色，我这里提供一种方法：https://www.jianshu.com/p/a0ab7a0bc03b
color_ct=c(brewer.pal(12, "Set3")[-c(2,3,9,12)],"#b3b3b3",
           brewer.pal(5, "Set1")[2],
           brewer.pal(3, "Dark2")[1],
           "#fc4e2a","#fb9a99","#f781bf","#e7298a")
names(color_ct)=sort(unique(as.character(testseu@meta.data$celltype)))

pb=point_data%>%ggplot(aes(x=celltype,y=0,size=cellnum,color=celltype))+geom_point()+
  scale_color_manual(values = color_ct)+
  theme_void()+guides(color = "none")
library(ggrepel)
library(patchwork)

### 热图绘制 ###################################################################
marker.dim=dim(markers_celltype)[1]
markers_celltype.b=markers_celltype[sample(1:marker.dim,marker.dim),]
markers_celltype.b=markers_celltype.b[!duplicated(markers_celltype.b$gene),]
#上面两步目的相当于重新打乱了这个数据框的顺序，然后去重，原因是
#markers_celltype中不可避免会出现一些基因重复出现的情况，举个例子：
#A和B两个cluster的marker基因各100个，有10个是相互重复的
#如果按照原来在数据框中出现的顺序A过了才是B，那么去重之后，A还剩100个记录，B还剩90，反映在图上面，对应的高亮基因块的高度是不一样的
#随机打乱再去重，可以保证A和B剩余的记录都是95左右，这样得到的图，A和B高亮的基因块的高度才会差不多高，和实际情况相符（两个cluster marker基因数差不多）
#即使A和B基因数不相等，也是类似的道理

markers_celltype.b$cluster=factor(markers_celltype.b$cluster,levels = rev(celltype_sort)) #注意因子顺序
markers_celltype.b=markers_celltype.b%>%arrange(cluster,gene) #这一行跟之前也不一样，之前排序是(cluster,avg_log2FC)，为什么这么做？原因等会儿看29行

bubble_gene=markers_celltype.b$gene
testseu@meta.data$celltype=factor(testseu@meta.data$celltype,levels = celltype_sort)#注意因子顺序
Idents(testseu)="celltype"
bubble_data=DotPlot(testseu,features = bubble_gene) #提取数据的简单方法
bubble_data=bubble_data$data

#实际分析中，可以自定义基因，整理成数据框就行。
#我们假设只想显示每个cluster top2的基因
#（像这种显示前几个基因的需求更多，如果按照avg_log2FC排序，这几个基因靠在一起，拉一根线显示一个label，
#加上R包的绘图函数会自动避免重叠，所以最终的显示是放射状的，像鸡爪子）
textdf=as.data.frame(markers_celltype.b %>% group_by(cluster) %>% top_n(2,wt=avg_log2FC))
textdf=data.frame(gene=textdf$gene,x=0.5)

#热图主体部分上下添加边框/线段
genenum=dim(markers_celltype.b)[1]
clusternum=length(unique(markers_celltype.b$cluster))
segment.df=data.frame(x=c(0.5,0.5),
                      xend=c(clusternum+0.5,clusternum+0.5),
                      y=c(0.5,genenum+0.5),
                      yend=c(0.5,genenum+0.5)
                      )

#将原来的因子变量转成数值变量，为了更方便控制横轴范围
bubble_data$cellid=as.numeric(bubble_data$id)
#按照原来的因子水平顺序，依次会被自动赋值为1到clusternum。（输入下一行代码就知道什么意思了）
table(bubble_data$cellid,bubble_data$id)

#数据准备好了，开始绘制热图
pc=ggplot()+
  geom_tile(data = bubble_data,aes(x=cellid,y=features.plot,fill=avg.exp.scaled))+
  geom_text_repel(data = textdf,
                  mapping = aes(x=x,y=gene,label=gene),
                  nudge_x = -0.5,
                  direction = "y", hjust = 1,segment.size = 0.2,
                  min.segment.length = 0,box.padding=0)+
  geom_vline(xintercept = c(0.5,clusternum+0.5))+
  geom_segment(data = segment.df,
               mapping = aes(x=x,xend=xend,y=y,yend=yend))+
  scale_x_continuous(expand = c(0,0),limits = c(-4,clusternum+0.5), #为了给基因名腾出空间，这里左边设置为负数，注意此时为-4，可以根据自己的图调整
                     breaks = unique(bubble_data$cellid),labels = levels(bubble_data$id))+
  scale_y_discrete(expand = c(0,0))+
  scale_fill_gradient2(low = "#0851fa",mid = "#f8fbfb",high = "#fc0301")+
  theme_void()+
  theme(
    panel.grid = element_blank(),
    axis.text.x.bottom = element_text(angle = 45,vjust = 1,hjust = 1,size = 14,color="black"),
  )
#需要注意的是，这张图的最左边到热图主体部分左边的距离是4.5(4+0.5)

(plot_spacer() + pa + plot_layout(widths = c(3.65,15))) / 
  (plot_spacer() + pb + plot_layout(widths = c(4.15,15))) / #这两个宽度比需要多试几次
  pc + plot_layout(heights = c(1,0.3,8))
ggsave("06-2pictures/01主要类型marker基因展示b.pdf",width = 20,height = 25,units = "cm") #保存之后如果图例被遮盖了一部分，需要用AI再编辑一下pdf

###图片整体还可以，就是聚类的那个是偏移的
#############################################################################################仍然是06-2
###02.两组比较_差异基因展示
library(Seurat)
library(tidyverse)
library(harmony)
library(ggrepel)
library(patchwork)

testseu<-scRNA_harmony_singler
testseu@meta.data$celltype<-testseu@meta.data$singleRnew
testseu@meta.data$condition<-testseu@meta.data$group
### 基于分组找差异基因 #########################################################
testseu@meta.data$celltype_condition=paste(testseu@meta.data$celltype,testseu@meta.data$condition,sep = "_")

marker_condition=data.frame()
Idents(testseu)="celltype_condition"
for ( ci in sort(as.character(unique(testseu@meta.data$celltype))) ) {
  tmp.marker <- FindMarkers(
    testseu, logfc.threshold = 0, min.pct = 0.1, #logfc不筛选
    only.pos = F, test.use = "wilcox",
    ident.1=paste0(ci,"_EcO"),ident.2=paste0(ci,"_Ctrl")
  )
  
  tmp.marker$gene=rownames(tmp.marker)
  tmp.marker$condition=ifelse(tmp.marker$avg_log2FC > 0,paste0(ci,"_EcO"),paste0(ci,"_Ctrl"))
  tmp.marker$cluster=ci
  
  #tmp.marker=tmp.marker%>%filter(p_val_adj < 0.01) #p_val_adj值不筛选
  tmp.marker=as.data.frame(tmp.marker)
  tmp.marker=tmp.marker%>%arrange(desc(avg_log2FC))
  
  marker_condition=marker_condition%>%rbind(tmp.marker)
}

# write.table(marker_condition,file = "markers.BasedOncondition.txt",quote = F,sep = "\t",row.names = F,col.names = T)
# marker_condition=read.table("markers.BasedOncondition.txt",header = T,sep = "\t",stringsAsFactors = F)

marker_condition$sig=""
marker_condition$sig[abs(marker_condition$avg_log2FC) > 0.25 & marker_condition$p_val_adj < 0.01] = "sig"
marker_condition$sig2=paste(marker_condition$cluster,marker_condition$sig,sep = "_")
marker_condition$sig2[str_detect(marker_condition$sig2,"_$")]="not_sig"
marker_condition$sig2=str_replace(marker_condition$sig2,"_sig","")

#控制顺序
marker_condition$sig2=factor(marker_condition$sig2,levels = c("not",sort(unique(marker_condition$cluster))))
marker_condition$cluster=factor(marker_condition$cluster,levels = sort(unique(marker_condition$cluster)))
marker_condition=marker_condition%>%arrange(cluster,sig2)
#控制范围
marker_condition$avg_log2FC[marker_condition$avg_log2FC > 3]=3
marker_condition$avg_log2FC[marker_condition$avg_log2FC < c(-3)]= -3

#配色
library(RColorBrewer)
library(scales)
color_ct=c(brewer.pal(12, "Set3"),
           brewer.pal(5, "Set1")[2],
           brewer.pal(3, "Dark2")[1])
names(color_ct)=sort(unique(as.character(marker_condition$cluster)))

#画图
marker_condition %>% ggplot(aes(x=cluster,y=avg_log2FC,color=sig2))+geom_jitter(width = 0.25,size=0.5)+
  scale_color_manual(values = c(color_ct,"not"="#dee1e6"))+
  scale_y_continuous("PD VS HC, average log2FC",expand = c(0.02,0))+
  theme_bw()+
  theme(
    panel.grid = element_blank(),
    legend.position = "none",
    axis.text.x.bottom = element_text(angle = 45,hjust = 1,size = 14,color = "black"),
    axis.text.y.left = element_text(size = 14,color = "black"),
    axis.title.x.bottom = element_blank(),
    axis.title.y.left = element_text(size = 16)
  )
ggsave("06-2pictures/02-1DEG_jitter1.pdf",width = 15,height = 12,units = "cm")  

#画图，改进
marker_condition2=marker_condition
marker_condition2$padj_log10_neg= -log10(marker_condition2$p_val_adj)
marker_condition2$padj_log10_neg=ifelse(marker_condition2$avg_log2FC > 0,
                                        marker_condition2$padj_log10_neg,
                                        -marker_condition2$padj_log10_neg)

plot.list=list()
for (ci in sort(unique(as.character(marker_condition2$cluster)))) {
  tmpdf=marker_condition2 %>% filter(cluster == ci)
  minabs=abs(min(tmpdf$padj_log10_neg))
  maxabs=max(tmpdf$padj_log10_neg)
  thre=0
  if(minabs < maxabs) {
    tmpdf$padj_log10_neg[tmpdf$padj_log10_neg > minabs] = minabs
    thre=minabs
  }
  if(minabs > maxabs) {
    tmpdf$padj_log10_neg[tmpdf$padj_log10_neg < (-maxabs)] = -maxabs
    thre=maxabs
  }
  if(minabs == maxabs & maxabs == Inf) {
    thre = min(
      abs(
        range(
          tmpdf$padj_log10_neg[tmpdf$padj_log10_neg < Inf & tmpdf$padj_log10_neg > -Inf]
        )
      )
    )
    tmpdf$padj_log10_neg[tmpdf$padj_log10_neg < (-thre)] = -thre
    tmpdf$padj_log10_neg[tmpdf$padj_log10_neg > thre] = thre
  }
  
  plotdata = tmpdf
  tmpdf=tmpdf%>%filter(sig2 != "not") #这里我取了logFC最极端的几个gene来标注文本，实际处理中不一定这样做
  tmpdf=tmpdf%>%arrange(desc(avg_log2FC))
  tmpdf.a=head(tmpdf%>%filter(avg_log2FC > 0),5)
  tmpdf.a$d=thre*2*0.05+(-thre)-tmpdf.a$padj_log10_neg
  tmpdf.b=tail(tmpdf%>%filter(avg_log2FC < 0),5)
  tmpdf.b$d=thre*2*0.95-thre  - tmpdf.b$padj_log10_neg
  textdata.down = tmpdf.b
  textdata.up   = tmpdf.a
  
  ###画图
  tmpplot=plotdata%>%ggplot(aes(x=padj_log10_neg,y=avg_log2FC))+
    geom_point(aes(color=sig2),size=1)+
    geom_hline(yintercept = c(-0.25,0.25),linetype="dashed")+
    geom_text_repel(data = textdata.down,
                    mapping = aes(label=gene),
                    nudge_x=textdata.down$d,
                    direction = "y", hjust = 1,segment.size = 0.2)+
    geom_text_repel(data = textdata.up,
                    mapping = aes(label=gene),
                    nudge_x=textdata.up$d,
                    direction = "y", hjust = 0,segment.size = 0.2)+
    labs(title = ci)+
    scale_color_manual(values = c(color_ct,"not"="#dee1e6"))+
    scale_y_continuous("PD VS HC, average log2FC",expand = c(0.02,0),limits = c(-3,3))+
    theme_bw()+
    theme(
      panel.grid = element_blank(),
      legend.position = "none",
      
      axis.ticks.x.bottom = element_blank(),
      axis.text.x.bottom = element_blank(),
      axis.title.x.bottom = element_blank(),
      axis.text.y.left = element_text(size = 14,color = "black"),
      axis.title.y.left = element_text(size = 16),
      
      plot.title = element_text(size = 16,hjust = 0.5)
    )
  
  index=which(ci == sort(unique(as.character(marker_condition2$cluster))))
  if (index!=1) {
    tmpplot=tmpplot+theme(
      axis.title.y.left = element_blank(),
      axis.ticks.y.left = element_blank(),
      axis.text.y.left = element_blank()
    )
  }
  if (index == length(sort(unique(as.character(marker_condition2$cluster))))) {
    segment.df=data.frame(x=c(0 - thre / 5,0 + thre / 5),
                          xend=c(-thre,thre),
                          y=c(-3,-3),
                          yend=c(-3,-3))
    tmpplot=tmpplot+geom_segment(data = segment.df,
                                 mapping = aes(x=x,xend=xend,y=y,yend=yend),
                                 arrow = arrow(length=unit(0.3, "cm")))
    
  }
  plot.list[[get("index")]]=tmpplot
}
wrap_plots(plot.list,ncol = 11)&theme(plot.margin = unit(c(0,0,0,0),"cm"))
ggsave("06-2pictures/02-2DEG_jitter2.pdf",width = 35,height = 18,units = "cm")


#########################################################还是06-2
######样本成分图
##############################################################################################

#load("/public/workspace/lincs/me/yao/01RDada/02_scRNA_harmony_singler.Rdata")
#scRNA_harmony<-scRNA_harmony_rm_double

scRNA1<-scRNA_harmony_singler
scRNA1@meta.data$celltype<-scRNA1@meta.data$singleRnew
x=scRNA1@meta.data$celltype
table(x)
pB2_df <- table(scRNA1@meta.data$celltype,scRNA1@meta.data$orig.ident) %>% melt()
colnames(pB2_df) <- c("Cluster","Sample","Number")
cluster=c( "B_cell", "DC_cell", "Endothelial_cell", "Epithelial_cell", "Fibroblast", "Macrophage", "NK_cell", "Smooth_muscle_cell","Stromal_cell", "T_cell","Tissue_stem_cell")

pB2_df$Cluster <- factor(pB2_df$Cluster,levels = cluster)
library(RColorBrewer)
##############################
#    "#F8766D" "#E68613" "#CD9600" "#ABA300" "#7CAE00" "#0CB702" "#00BE67" "#00C19A" "#00BFC4" "#00B8E7" "#00A9FF" "#8494FF" "#C77CFF" "#ED68ED" "#FF61CC" "#FF68A1"

作者：Aji
链接：https://www.jianshu.com/p/229af1b135b5
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
#########################################################
sample_color <- c("#F8766D","#E68613","#CD9600","#ABA300","#7CAE00","#0CB702","#00BE67","#00C19A","#00BFC4","#00B8E7","#00A9FF","#8494FF","#C77CFF","#ED68ED")

pB4 <- ggplot(data = pB2_df, aes(x =Number, y = Sample, fill =  Cluster)) +
  geom_bar(stat = "identity", width=0.8,position="fill")+
  scale_fill_manual(values=sample_color) +
  theme_bw()+
  theme(panel.grid =element_blank()) +
  labs(x="",y="Ratio")+
  ####用来将y轴移动位置
  theme(axis.text.y = element_text(size=12, colour = "black"))+
  theme(axis.text.x = element_text(size=12, colour = "black"))
pB4
ggsave("06-2pictures/03-sample-ratio.pdf",width = 16,height = 22,units = "cm")



#############################################################################################还是06-2
#############################巨噬细胞细胞两组的差异基因比较

library(ggrepel)
####

#加载单个样本单细胞数据分析结果
scRNA_harmony<-scRNA_harmony_singler
###用cd4.naive代替中性粒细胞子集
cd4.naive<-subset(scRNA_harmony,singleRnew=="Macrophage")
Idents(cd4.naive)<-cd4.naive@meta.data$group
#挑选B细胞相对于CD8T细胞特意性高表达的marker基因
cd4.naive.deg=FindMarkers(cd4.naive, ident.1="EcO",ident.2="Ctrl",only.pos = F, min.pct = 0.01, logfc.threshold = 0.01)



#cd4.naive <- subset(scRNA1 ,idents = "0")
#Idents(cd4.naive) <- "orig.ident"
#cd4.naive.deg=FindMarkers(cd4.naive,ident.1 = "DapiNeg1",ident.2 = "DapiNeg2")
avg.cd4.naive <- log1p(AverageExpression(cd4.naive, verbose = FALSE)$RNA)
avg.cd4.naive= as.data.frame(avg.cd4.naive)
avg.cd4.naive$gene <- rownames(avg.cd4.naive)
genes.to.label = rownames(cd4.naive.deg)[1:30]
avg.cd4.naive$Sig="NO_DIFF"
avg.cd4.naive$Sig[avg.cd4.naive$gene %in%genes.to.label]="DIFF"

p=ggplot(avg.cd4.naive, aes(EcO,Ctrl))+xlim(0,4.5)+ylim(0,4.5)+
  geom_point(aes(color=Sig),size=1)+theme_classic()+
  scale_color_manual(values = c("#f53f38","#b6bbc2"))
data_selected <- avg.cd4.naive[rownames(cd4.naive.deg),]
pdf("06-2pictures/04velo.pdf")
p + geom_label_repel(data=data_selected,label.size=0.1,size =3,
                     aes(label=rownames(data_selected)))+ggtitle("Mix") + theme(plot.title = element_text(hjust = 0.5))
dev.off()










###################################################################################################07桑基图---1对1样本，不用做
#install.packages("ggplot2")
#install.packages("ggalluvial")
if (!dir.exists("07ggalluvial")){
dir.create("07ggalluvial")
}

library(ggalluvial)
library(ggplot2)
library(dplyr)

#inputFile="input.txt"         
outFile="07ggalluvial/ggalluvial.pdf"    
rt<-data.frame(orig.ident=scRNA_harmony@meta.data$orig.ident,celltype=scRNA_harmony@meta.data$singleRnew,group=scRNA_harmony@meta.data$group)
#rt=read.table(inputFile, header = T, sep="\t", check.names=F)     
corLodes=to_lodes_form(rt, axes = 1:ncol(rt), id = "Cohort")

#得到输出文件
pdf(file=outFile,width=8,height=6)
mycol <- rep(c("#029149","#6E568C","#E0367A","#D8D155","#223D6C","#D20A13","#431A3D","#91612D","#FFD121","#088247","#11AA4D","#58CDD9","#7A142C","#5D90BA","#64495D","#7CC767"),15)
ggplot(corLodes, aes(x = x, stratum = stratum, alluvium = Cohort,fill = stratum, label = stratum)) +
  	 scale_x_discrete(expand = c(0, 0)) +  
  	 #用aes.flow控制线调颜色，forward说明颜色和前面一致，backward说明与后面一致
  	 geom_flow(width = 2/10,aes.flow = "forward") + 
	 geom_stratum(alpha = .9,width = 2/10) +
	 scale_fill_manual(values = mycol) +
	 #size = 2代表基因名字大小
	 geom_text(stat = "stratum", size = 2,color="black") +
	 xlab("") + ylab("") + theme_bw() + 
	 theme(axis.line = element_blank(),axis.ticks = element_blank(),axis.text.y = element_blank()) + 
	 theme(panel.grid =element_blank()) + 
	 theme(panel.border = element_blank()) + 
	 ggtitle("") + guides(fill = FALSE)                            
dev.off()


##############################################################################08GSEA
####Stromal cells


library(Seurat)
library(msigdbr)
library(GSVA)
library(tidyverse)
library(clusterProfiler)
library(patchwork)
library(fgsea)
library(dplyr)
library(ggplot2)

if (!dir.exists("08gesa")){
dir.create("08gesa")
}

#加载单个样本单细胞数据分析结果
load("/public/workspace/lincs/me/yao/01RDada/02_scRNA_harmony_singler.Rdata")
scRNA<-subset(scRNA_harmony_singler,singleRnew=="Stromal cells")
Idents(scRNA)<-scRNA@meta.data$group
#挑选B细胞相对于CD8T细胞特意性高表达的marker基因
T_vs_M=FindMarkers(scRNA, ident.1="T",ident.2="M",only.pos = F, min.pct = 0.01, logfc.threshold = 0.01)
save(T_vs_M,file="T_vs_M.RData")
singularity shell /public/workspace/lincs/lab7/RNAseq/downstream/lcs_rnaseq20231220.sif
R
setwd("/public/workspace/lincs/me/yao/")
load("T_vs_M.RData")
#制作geneList
#值为log2FC
geneList= T_vs_M$avg_log2FC 
#name为基因名字
names(geneList)= rownames(T_vs_M)
#按FC从大到小排序
geneList=sort(geneList,decreasing = T)
head(geneList)
library(ggplot2)
library(clusterProfiler)
library(org.Hs.eg.db)
library(GSEABase)
library(enrichplot)

#从GSEA官网下载GSEA分析需要的基因集
#http://www.gsea-msigdb.org/gsea/index.jsp

#下载免疫相关的基因集，Hallmark gene sets 
gmtfile ='/public/workspace/lincs/me/yao/mh.all.v2023.2.Mm.symbols.gmt'

#读取gmt文件中的pathway信息
pathway<-read.gmt(gmtfile)
#进行GSEA分析
y <- GSEA(geneList,TERM2GENE =pathway, minGSSize = 1,pvalueCutoff = 0.5)

#保存GSEA分析结果
write.csv(file="08gesa/01_HALLMARK_T_vs_M_Stromal cells_GSEA_result.csv",data.frame(y))

#气泡图展示显著富集的前20条通路
pdf(file="08gesa/01_HALLMARK_T_vs_M_Stromal cells_GSEA_dotplot.pdf",width=15,height=20)
dotplot(y,showCategory=20)
dev.off()

############
#下载免疫相关的基因集，M2: curated gene sets

gmtfile ='/public/workspace/lincs/me/yao/m2.all.v2023.2.Mm.symbols.gmt'

#读取gmt文件中的pathway信息
pathway<-read.gmt(gmtfile)
#进行GSEA分析
y <- GSEA(geneList,TERM2GENE =pathway, minGSSize = 1,pvalueCutoff = 0.5)

#保存GSEA分析结果
write.csv(file="08gesa/02_M2_T_vs_M_Stromal cells_GSEA_result.csv",data.frame(y))

#气泡图展示显著富集的前20条通路
pdf(file="08gesa/02_M2_T_vs_M_Stromal cells_GSEA_dotplot.pdf",width=25,height=20)
dotplot(y,showCategory=50)
dev.off()



#绘制具体通路的GSEA图
library(enrichplot)
pdf(file="08gesa/03INFLAMMATORY_T_vs_M_Stromal cells_gsea.pdf",width=12)
gseaplot2(y,geneSetID = 'HALLMARK_INFLAMMATORY_RESPONSE',pvalue_table=T)
dev.off()

Tf(file="08gesa/T_vs_M_Stromal cells_gsea2.Tf",width=12)
gseaplot2(y,geneSetID = 'HALLMARK_IL2_STAT5_SIGNALING',pvalue_table=T) 
dev.off()

##################################################
#从GSEA官网下载GSEA分析需要的基因集
#http://www.gsea-msigdb.org/gsea/index.jsp

#下载免疫相关的基因集，c7: immunologic signature gene sets
gmtfile ='/public/workspace/lincs/lab7/oral/new/h.all.v7.4.symbols.gmt'

#读取gmt文件中的pathway信息
pathway<-read.gmt(gmtfile)
#进行GSEA分析
y <- GSEA(geneList,TERM2GENE =pathway, minGSSize = 1,pvalueCutoff = 0.5)

#保存GSEA分析结果
write.csv(file="08gesa/T_vs_M_Stromal cells_GSEA_result_hallmark.csv",data.frame(y))

#气泡图展示显著富集的前20条通路
Tf(file="08gesa/T_vs_M_Stromal cells_GSEA_dotplot_hallmark.Tf",width=10,height=12)
dotplot(y,showCategory=20)
dev.off()

#绘制具体通路的GSEA图
library(enrichplot)
Tf(file="08gesa/T_vs_M_Stromal cells_gsea.Tf",width=12)
gseaplot2(y,geneSetID = 'HALLMARK_IL2_STAT5_SIGNALING',pvalue_table=T)
dev.off()

Tf(file="08gesa/T_vs_M_Stromal cells_gsea2.Tf",width=12)
gseaplot2(y,geneSetID = 'HALLMARK_TNFA_SIGNALING_VIA_NFKB',pvalue_table=T) 
dev.off()

######################################################接着把GO和KEGG做了
dge.State<-T_vs_M
sig_dge.State <- subset(dge.State, p_val_adj<0.01&abs(avg_log2FC)>1)
#差异基因GO富集分析
#########################
ego_ALL <- enrichGO(gene          = row.names(sig_dge.State),
                   OrgDb         = 'org.Mm.eg.db',
                   keyType       = 'SYMBOL',
                   ont           = "ALL",
                   pAdjustMethod = "BH",
                   pvalueCutoff  = 0.01,
                   qvalueCutoff  = 0.05)
ego_all <- data.frame(ego_ALL)
write.csv(ego_all,'08gesa/3enrichGO.csv')    
#####################################       
ego_CC <- enrichGO(gene          = row.names(sig_dge.State),
                   OrgDb         = 'org.Mm.eg.db',
                   keyType       = 'SYMBOL',
                   ont           = "CC",
                   pAdjustMethod = "BH",
                   pvalueCutoff  = 0.01,
                   qvalueCutoff  = 0.05)
ego_MF <- enrichGO(gene          = row.names(sig_dge.State),
                   OrgDb         = 'org.Mm.eg.db',
                   keyType       = 'SYMBOL',
                   ont           = "MF",
                   pAdjustMethod = "BH",
                   pvalueCutoff  = 0.01,
                   qvalueCutoff  = 0.05)
ego_BP <- enrichGO(gene          = row.names(sig_dge.State),
                   OrgDb         = 'org.Mm.eg.db',
                   keyType       = 'SYMBOL',
                   ont           = "BP",
                   pAdjustMethod = "BH",
                   pvalueCutoff  = 0.01,
                   qvalueCutoff  = 0.05) 
ego_CC@result$Description <- substring(ego_CC@result$Description,1,70)
ego_MF@result$Description <- substring(ego_MF@result$Description,1,70)
ego_BP@result$Description <- substring(ego_BP@result$Description,1,70)
p_BP <- barplot(ego_BP,showCategory = 20) + ggtitle("barplot for Biological process")
p_CC <- barplot(ego_CC,showCategory = 20) + ggtitle("barplot for Cellular component")
p_MF <- barplot(ego_MF,showCategory = 20) + ggtitle("barplot for Molecular function")
plotc <- p_BP/p_CC/p_MF
ggsave(plotc, file='08gesa/3enrichGO.pdf',width = 20,height = 40)

genelist <- bitr(row.names(sig_dge.State), fromType="SYMBOL",
                           toType="ENTREZID", OrgDb='org.Mm.eg.db')
genelist <- pull(genelist,ENTREZID)               
ekegg <- enrichKEGG(gene = genelist, organism = 'mmu')
p1 <- barplot(ekegg, showCategory=20)
p2 <- dotplot(ekegg, showCategory=20)
plotc = p1/p2

ggsave(plotc,file="08gesa/4enrichKEGG.pdf", width = 12, height = 10)




####################################只看中性粒细胞的GSVA
##################两组gsva
expr <- AverageExpression(scRNA, assays = "RNA", slot = "data")[[1]]
#View(expr)
#选取非零基因
expr <- expr[rowSums(expr)>0,]
#转换成矩阵
expr <- as.matrix(expr)

#从GSEA官网下载GSEA分析需要的基因集
#http://www.gsea-msigdb.org/gsea/index.jsp

#下载免疫相关的基因集，h: hallmark gene sets
gmtfile ='/public/workspace/lincs/me/yao/mh.all.v2023.2.Mm.symbols.gmt'

#读取gmt文件中的pathway信息
pathway<-read.gmt(gmtfile)[,c(2,1)]
#去堆叠,转换成list
genesets=unstack(pathway)

#进行GSVA分析
gsva.res <- gsva(expr, genesets, method="ssgsea")
#保存GSVA分析结果
gsva.df <- data.frame(Genesets=rownames(gsva.res), gsva.res, check.names = F)
if (!dir.exists("09gsva")){
dir.create("09gsva")
}

write.csv(gsva.df, "09gsva/01only_Stromal cells_gsva_res.csv", row.names = F)

#绘制热图
library(pheatmap)
pdf(file="09gsva/01only_Stromal cells_GSVA_heatmap.pdf",width=12,height=8)
pheatmap(gsva.res, show_colnames = T, scale = "row")
dev.off()


library(pheatmap)

A<-read.csv("09gsva/01only_Stromal cells_gsva_res.csv")
rownames(A)<-A$Genelists
A<-A[,-1]
rownames(A)<-gsub("HALLMARK_","",rownames(A))
pdf(file="09gsva/01only_Stromal cells_GSVA_heatmap22.pdf",width=6,height=8)
pheatmap(A, show_colnames = T, scale = "row",col = rainbow(11)[4:8])
dev.off()
###################################################################################09GSVA--这个是样本的GSVA



library(Seurat)
library(msigdbr)
library(GSVA)
library(tidyverse)
library(clusterProfiler)
library(patchwork)
library(fgsea)
library(dplyr)
library(ggplot2)
#load('scRNA_harmony.Rdata')

if (!dir.exists("09gsva")){
dir.create("09gsva")
}

scRNA_harmony<-scRNA_harmony_singler
#####样本分组和细胞信息联合起来，变成新的分组信息
scRNA_harmony@meta.data$newgroup<-as.factor(paste0(scRNA_harmony@meta.data$group,"_",scRNA_harmony@meta.data$singleRnew))
#获取细胞类型
scRNA<-scRNA_harmony
Idents(scRNA)<-scRNA@meta.data$newgroup
#计算每个基因在每个细胞亚群中的平均表达值
expr <- AverageExpression(scRNA, assays = "RNA", slot = "data")[[1]]
#View(expr)
#选取非零基因
expr <- expr[rowSums(expr)>0,] 
#转换成矩阵
expr <- as.matrix(expr)


#从GSEA官网下载GSEA分析需要的基因集
#http://www.gsea-msigdb.org/gsea/index.jsp

#下载免疫相关的基因集，h: hallmark gene sets
gmtfile ='/public/workspace/lincs/me/yao/mh.all.v2023.2.Mm.symbols.gmt'

#读取gmt文件中的pathway信息
pathway<-read.gmt(gmtfile)[,c(2,1)]
#去堆叠,转换成list
genesets=unstack(pathway)

#进行GSVA分析
gsva.res <- gsva(expr, genesets, method="ssgsea") 
#保存GSVA分析结果
gsva.df <- data.frame(Genesets=rownames(gsva.res), gsva.res, check.names = F)
write.csv(gsva.df, "09gsva/gsva_res.csv", row.names = F)

#绘制热图
library(pheatmap)
pdf(file="09gsva/GSVA_heatmap.pdf",width=12,height=8)
pheatmap(gsva.res, show_colnames = T, scale = "row")
dev.off()

############save.image(file="20221022.RData")
######################################################chat分组重新跑
########对照之前须先分别跑正常和重症组
#################################################################################10 首先跑对照组
#cellchat   20240102重新跑screen -S hc11
#单数据集
load("/home/server/data1/jyz/Ctrl_EcO/01RDada/06_scRNA_harmony_singler20240621.Rdata")
####
scRNA_harmony<-scRNA_harmony_singler2
library(Seurat)#载入R包
library(ggplot2)
library(CellChat)
library(patchwork)
library(NMF)
if (!dir.exists("10chat_hc")){
dir.create("10chat_hc")
}

setwd("./10chat_hc")#切换工作目录
# 创建cellchat对象
seurat=subset(scRNA_harmony,group=="Ctrl")#读取seurat对象
data.input = as.matrix(GetAssayData(seurat, assay = "RNA", slot = "data"))#得到标准化表达矩阵
meta = seurat@meta.data # 获得实验信息
cellchat <- createCellChat(object = data.input, meta = meta, group.by = "singleRnew")#创建cellchat对象

levels(cellchat@idents) # 显示细胞类型
groupSize <- as.numeric(table(cellchat@idents)) # 每种细胞类型的细胞数目统计
groupSize

CellChatDB <- CellChatDB.human # 若是小鼠，请用 CellChatDB.mouse 数据库
showDatabaseCategory(CellChatDB)#显示数据库中的配受体分类

cellchat@idents = droplevels(cellchat@idents, exclude = setdiff(levels(cellchat@idents),unique(cellchat@idents)))#丢弃未使用的因子水平，在我们这个例子数据中需要该步骤


cellchat@DB <- CellChatDB #数据库赋值
cellchat <- subsetData(cellchat) # 必须，即时是整个数据集
cellchat <- identifyOverExpressedGenes(cellchat)#鉴定过表达基因
cellchat <- identifyOverExpressedInteractions(cellchat)#鉴定过表达互作
cellchat <- projectData(cellchat, PPI.human)#将基因表达数据映射PPT互作网络

#################################Inference of cell-cell communication network#####################################
cellchat <- computeCommunProb(cellchat)#计算互作概率
cellchat <- filterCommunication(cellchat, min.cells = 1)#过滤掉低于min.cells的细胞类型
cellchat <- computeCommunProbPathway(cellchat)#计算pathway水平的互作概率，通过总结所有的配受体对
cellchat <- aggregateNet(cellchat)#得到整体细胞互作网络
save(cellchat,file="cellchat_hc.RData")
cellchat@netP$pathways#显示显著的pathways
######一定要看结果

 [1] "COLLAGEN"   "MIF"        "MK"         "MHC-II"     "LAMININ"
 [6] "APP"        "MHC-I"      "CD99"       "GALECTIN"   "PTN"
[11] "FN1"        "VISFATIN"   "THBS"       "CCL"        "ANNEXIN"
[16] "CLEC"       "THY1"       "VEGF"       "ITGB2"      "PECAM1"
[21] "ADGRE5"     "JAM"        "NOTCH"      "COMPLEMENT" "ICAM"
[26] "GAS"        "PARs"       "CD46"       "ANGPT"      "ncWNT"
[31] "SPP1"       "PROS"       "ESAM"       "EDN"        "SELL"
[36] "CD22"       "CD45"       "GRN"        "TWEAK"      "PDGF"
[41] "CADM"       "CDH5"       "TGFb"       "SEMA4"      "IL16"
[46] "WNT"        "BAFF"       "FGF"        "EPHB"       "OSM"
[51] "ANGPTL"     "CDH1"       "CXCL"       "LIGHT"      "IGF"
[56] "HSPG"       "BMP"        "TENASCIN"   "MPZ"        "BAG"
[61] "SELPLG"     "SEMA3"      "APRIL"      "EGF"        "PERIOSTIN"
[66] "CDH"        "LIFR"       "IL1"        "DESMOSOME"  "AGRN"
[71] "EPHA"       "NRXN"       "CSPG4"      "PTPRM"      "HGF"
[76] "FASLG"      "OCLN"






pdf("01-1count_weight.pdf")
netVisual_circle(cellchat@net$count, vertex.weight = groupSize, weight.scale = T, label.edge= F, title.name = "Number of interactions")#互作数目
dev.off()

pdf("01-2count_weight.pdf")
netVisual_circle(cellchat@net$weight, vertex.weight = groupSize, weight.scale = T, label.edge= F, title.name = "Interaction weights/strength")#互作强度
dev.off()







mat <- cellchat@net$weight#互作强度值
pdf("02allcell_count_weight.pdf")
par(mfrow = c(3,4), xpd=TRUE) # 设定绘图区，3行4列
for (i in 1:nrow(mat)) {
  mat2 <- matrix(0, nrow = nrow(mat), ncol = ncol(mat), dimnames = dimnames(mat))#构建1个0值矩阵
  mat2[i, ] <- mat[i, ]#替换掉矩阵对应行
  netVisual_circle(mat2, vertex.weight = groupSize, weight.scale = T, edge.weight.max = max(mat), title.name = rownames(mat)[i])#网络图
}
dev.off()
# 层次图
levels(cellchat@idents) 
pathways.show <- "CCL"#指定信号通路
vertex.receiver = 6 # 指定目标细胞类型
netVisual_aggregate(cellchat, signaling = pathways.show,  vertex.receiver = vertex.receiver,layout = "circle")#绘图
# 所有显著pathways
pathways.show.all <- cellchat@netP$pathways

for (i in 1:length(pathways.show.all)) {
  # 信号pathway以及对应的每个配受体对可视化，网络图，弦图，热图
  netVisual(cellchat, signaling = pathways.show.all[i], layout = "circle",out.format=c("pdf"))#网络图
  netVisual(cellchat, signaling = pathways.show.all[i], layout = "chord",out.format=c("pdf"),height=12)#弦图
  pdf(file=paste0("03-1",pathways.show.all[i], "_heatmap.pdf"))#热图
  print(netVisual_heatmap(cellchat, signaling = pathways.show.all[i], color.heatmap = "Reds"))
  dev.off()
  # 计算每个配受体对对信号通路的贡献大小
  print("LR contribution!")
  gg <- netAnalysis_contribution(cellchat, signaling = pathways.show.all[i])#绘图
  ggsave(filename=paste0("03-2",pathways.show.all[i], "_L-R_contribution.pdf"), plot=gg, width = 8, height = 8, units = 'in', dpi = 300)#保存图片
}

#对感兴趣的细胞类型，气泡图显示所有显著LR对
pdf("03-0netVisual_bubble.pdf",width=10,height=20)
netVisual_bubble(cellchat, sources.use = c(1:5,7:11), targets.use = 6, remove.isolate = FALSE)
dev.off()
#绘制感兴趣信号通路相关配受体对的基因表达图

pdf("03-1-plotGeneExpression.pdf",width=8,height=10)
plotGeneExpression(cellchat, signaling = "CCL")
dev.off()


# 网络分析
cellchat <- netAnalysis_computeCentrality(cellchat, slot.name = "netP") # 计算信号通路的网络中心得分
# 热图可视化细胞所扮演的主要角色，亦可用散点图来表示
for(i in 1:length(pathways.show.all)){
  pdf(file=paste0("04-1",pathways.show.all[i], "_major_signaling_roles_heatmap.pdf"),width=10,height=8)#热图
  print(netAnalysis_signalingRole_network(cellchat, signaling = pathways.show.all[i], width = 8, height = 2.5, font.size = 10))
  dev.off()
  pdf(file=paste0("04-2",pathways.show.all[i], "_major_signaling_roles_scatter.pdf"),width=8,height=8)#散点图
  print(netAnalysis_signalingRole_scatter(cellchat,signaling = pathways.show.all[i]))
  dev.off()
}

# 所有信号通路汇总分析，看哪个信号通路贡献最大
pdf("05netAnalysis_signalingRole_heatmap.pdf",height=32,width=18)
par(mfrow = c(1,2))#
ht1 <- netAnalysis_signalingRole_heatmap(cellchat, pattern = "outgoing",width=10,height=30)
ht2 <- netAnalysis_signalingRole_heatmap(cellchat, pattern = "incoming",width=10,height=30)


ht1 + ht2
dev.off()
#保存结果
df.net <- subsetCommunication(cellchat)#得到细胞互作数据框
write.csv(df.net,"06-net_lr.csv")#输出文件
df.netp <- subsetCommunication(cellchat,slot.name = "netP")#得到信号通路水平的细胞互作结果
write.csv(df.netp,"07-net_pathway.csv")#输出文件
cellchat_HC<-cellchat
saveRDS(cellchat_HC, file = "HC_cellchat_single_dataset.rds")#保存cellchat对象为rds文件




##########################################################################################11 跑重症组
#cellchat  20221026重新跑screen -S pd11
#单数据集
load("/home/server/data1/jyz/Ctrl_EcO/01RDada/06_scRNA_harmony_singler20240621.Rdata")
####
scRNA_harmony<-scRNA_harmony_singler2
library(Seurat)#载入R包
library(ggplot2)
library(CellChat)
library(patchwork)
library(NMF)
if (!dir.exists("11chat_pd")){
dir.create("11chat_pd")
}

setwd("./11chat_pd")#切换工作目录
# 创建cellchat对象
seurat=subset(scRNA_harmony,group=="EcO")#读取seurat对象
data.input = as.matrix(GetAssayData(seurat, assay = "RNA", slot = "data"))#得到标准化表达矩阵
meta = seurat@meta.data # 获得实验信息
cellchat <- createCellChat(object = data.input, meta = meta, group.by = "singleRnew")#创建cellchat对象

levels(cellchat@idents) # 显示细胞类型
groupSize <- as.numeric(table(cellchat@idents)) # 每种细胞类型的细胞数目统计
groupSize

CellChatDB <- CellChatDB.human # 若是小鼠，请用 CellChatDB.mouse 数据库
#showDatabaseCategory(CellChatDB)#显示数据库中的配受体分类

cellchat@idents = droplevels(cellchat@idents, exclude = setdiff(levels(cellchat@idents),unique(cellchat@idents)))#丢弃未使用的因子水平，在我们这个例子数据中需要该步骤


cellchat@DB <- CellChatDB #数据库赋值
cellchat <- subsetData(cellchat) # 必须，即时是整个数据集
cellchat <- identifyOverExpressedGenes(cellchat)#鉴定过表达基因
cellchat <- identifyOverExpressedInteractions(cellchat)#鉴定过表达互作
cellchat <- projectData(cellchat, PPI.human)#将基因表达数据映射PPT互作网络

#################################Inference of cell-cell communication network#####################################
cellchat <- computeCommunProb(cellchat)#计算互作概率
cellchat <- filterCommunication(cellchat, min.cells = 1)#过滤掉低于min.cells的细胞类型
cellchat <- computeCommunProbPathway(cellchat)#计算pathway水平的互作概率，通过总结所有的配受体对
cellchat <- aggregateNet(cellchat)#得到整体细胞互作网络
save(cellchat,file="cellchat_pd.RData")
cellchat@netP$pathways#显示显著的pathways
######一定要看结果


 [1] "COLLAGEN"   "MIF"        "MHC-I"      "LAMININ"    "MK"
 [6] "APP"        "FN1"        "CD99"       "CLEC"       "VISFATIN"
[11] "MHC-II"     "CXCL"       "GALECTIN"   "ADGRE5"     "CD45"
[16] "PTN"        "THBS"       "CCL"        "NOTCH"      "PARs"
[21] "CD46"       "ANNEXIN"    "GAS"        "ncWNT"      "VEGF"
[26] "ITGB2"      "SPP1"       "COMPLEMENT" "PECAM1"     "PDGF"
[31] "ESAM"       "PROS"       "JAM"        "EGF"        "CD22"
[36] "ANGPT"      "ANGPTL"     "CLDN"       "CDH5"       "THY1"
[41] "FGF"        "TENASCIN"   "MPZ"        "ICAM"       "NCAM"
[46] "SEMA3"      "HSPG"       "CALCR"      "VCAM"       "PERIOSTIN"
[51] "WNT"        "SEMA4"      "CDH"        "TGFb"       "EPHB"
[56] "EDN"        "PTPRM"      "IGF"        "BAFF"       "AMH"
[61] "EPHA"       "SEMA5"      "BMP"        "MAG"        "CADM"
[66] "APRIL"






pdf("01-1count_weight.pdf")
netVisual_circle(cellchat@net$count, vertex.weight = groupSize, weight.scale = T, label.edge= F, title.name = "Number of interactions")#互作数目
dev.off()

pdf("01-2count_weight.pdf")
netVisual_circle(cellchat@net$weight, vertex.weight = groupSize, weight.scale = T, label.edge= F, title.name = "Interaction weights/strength")#互作强度
dev.off()

mat <- cellchat@net$weight#互作强度值
pdf("02allcell_count_weight.pdf")
par(mfrow = c(3,4), xpd=TRUE) # 设定绘图区，3行4列
for (i in 1:nrow(mat)) {
  mat2 <- matrix(0, nrow = nrow(mat), ncol = ncol(mat), dimnames = dimnames(mat))#构建1个0值矩阵
  mat2[i, ] <- mat[i, ]#替换掉矩阵对应行
  netVisual_circle(mat2, vertex.weight = groupSize, weight.scale = T, edge.weight.max = max(mat), title.name = rownames(mat)[i])#网络图
}
dev.off()
# 层次图
levels(cellchat@idents) 
pathways.show <- "CCL"#指定信号通路
vertex.receiver = 6 # 指定目标细胞类型
netVisual_aggregate(cellchat, signaling = pathways.show,  vertex.receiver = vertex.receiver,layout = "circle")#绘图
# 所有显著pathways
pathways.show.all <- cellchat@netP$pathways

for (i in 1:length(pathways.show.all)) {
  # 信号pathway以及对应的每个配受体对可视化，网络图，弦图，热图
  netVisual(cellchat, signaling = pathways.show.all[i], layout = "circle",out.format=c("pdf"))#网络图
  netVisual(cellchat, signaling = pathways.show.all[i], layout = "chord",out.format=c("pdf"),height=12)#弦图
  pdf(file=paste0("03-1",pathways.show.all[i], "_heatmap.pdf"))#热图
  print(netVisual_heatmap(cellchat, signaling = pathways.show.all[i], color.heatmap = "Reds"))
  dev.off()
  # 计算每个配受体对对信号通路的贡献大小
  print("LR contribution!")
  gg <- netAnalysis_contribution(cellchat, signaling = pathways.show.all[i])#绘图
  ggsave(filename=paste0("03-2",pathways.show.all[i], "_L-R_contribution.pdf"), plot=gg, width = 8, height = 8, units = 'in', dpi = 300)#保存图片
}

#对感兴趣的细胞类型，气泡图显示所有显著LR对
pdf("03-0netVisual_bubble.pdf",width=10,height=20)
netVisual_bubble(cellchat, sources.use = c(1:5,7:11), targets.use = 6, remove.isolate = FALSE)
dev.off()
#绘制感兴趣信号通路相关配受体对的基因表达图

pdf("03-1-plotGeneExpression.pdf",width=8,height=10)
plotGeneExpression(cellchat, signaling = "CCL")
dev.off()


# 网络分析
cellchat <- netAnalysis_computeCentrality(cellchat, slot.name = "netP") # 计算信号通路的网络中心得分
# 热图可视化细胞所扮演的主要角色，亦可用散点图来表示
for(i in 1:length(pathways.show.all)){
  pdf(file=paste0("04-1",pathways.show.all[i], "_major_signaling_roles_heatmap.pdf"),width=10,height=8)#热图
  print(netAnalysis_signalingRole_network(cellchat, signaling = pathways.show.all[i], width = 8, height = 2.5, font.size = 10))
  dev.off()
  pdf(file=paste0("04-2",pathways.show.all[i], "_major_signaling_roles_scatter.pdf"),width=8,height=8)#散点图
  print(netAnalysis_signalingRole_scatter(cellchat,signaling = pathways.show.all[i]))
  dev.off()
}

# 所有信号通路汇总分析，看哪个信号通路贡献最大
pdf("05netAnalysis_signalingRole_heatmap.pdf",height=32,width=18)
par(mfrow = c(1,2))#
ht1 <- netAnalysis_signalingRole_heatmap(cellchat, pattern = "outgoing",width=10,height=30)
ht2 <- netAnalysis_signalingRole_heatmap(cellchat, pattern = "incoming",width=10,height=30)


ht1 + ht2
dev.off()
#保存结果
df.net <- subsetCommunication(cellchat)#得到细胞互作数据框
write.csv(df.net,"06-net_lr.csv")#输出文件
df.netp <- subsetCommunication(cellchat,slot.name = "netP")#得到信号通路水平的细胞互作结果
write.csv(df.netp,"07-net_pathway.csv")#输出文件
cellchat_PD<-cellchat
saveRDS(cellchat_PD, file = "PD_cellchat_single_dataset.rds")#保存cellchat对象为rds文件

#########################################################12cellchat多数据集
#拥有相同细胞构成的多个数据集比较分析
library(CellChat)#载入R包
library(patchwork)
setwd("/home/server/data1/jyz/Ctrl_EcO/")
if (!dir.exists("12chat_multi")){
dir.create("12chat_multi")
}
setwd("./12chat_multi")#切换工作目录


cellchat.ctrl <- readRDS("../10chat_hc/HC_cellchat_single_dataset.rds")#读取ctrl的cellchat对象
cellchat.treat <- readRDS("../11chat_pd/PD_cellchat_single_dataset.rds")#读取treat的cellchat对象
object.list <- list(hc= cellchat.ctrl, pd= cellchat.treat)#创建列表
cellchat <- mergeCellChat(object.list, add.names = names(object.list))#合并cellchat对象

pdf(file="01num_weight.pdf",width=16,height=8)
#互作数目和强度比较
gg1 <- compareInteractions(cellchat, show.legend = F, group = c(1,2))#互作数目
gg2 <- compareInteractions(cellchat, show.legend = F, group = c(1,2), measure = "weight")#互作强度
gg1 + gg2
dev.off()
#circle plot，网络图
pdf(file="02circle_plot.pdf",width=16,height=8)
par(mfrow = c(1,2), xpd=TRUE)#设置绘图区域,1行2列
netVisual_diffInteraction(cellchat, weight.scale = T)#互作数目
netVisual_diffInteraction(cellchat, weight.scale = T, measure = "weight")#互作强度
dev.off()
#heatmap，热图
pdf(file="03heatmap.pdf",width=16,height=8)
gg1 <- netVisual_heatmap(cellchat)#互作数目
gg2 <- netVisual_heatmap(cellchat, measure = "weight")#互作强度
gg1 + gg2
dev.off()
#上述差异分析只适合两组比较，如果超过两组，可以采用下面的方式来比较分析。
weight.max <- getMaxWeight(object.list, attribute = c("idents","count"))#获得多个数据集间最大的边权重
#par(mfrow = c(1,2), xpd=TRUE)#设置绘图区域，1行2列
for (i in 1:length(object.list)) {#依次绘制每个数据对象的互作网络图
  p<-netVisual_circle(object.list[[i]]@net$count, weight.scale = T, label.edge= F, edge.weight.max = weight.max[2], edge.width.max = 12, title.name = paste0("Number of interactions - ", names(object.list)[i]))
  ggsave(filename=paste0("04-",i, "_network.pdf"), plot=p, width = 8, height = 8, units = 'in', dpi = 300)#保存图片
}

#发送（outgoing）和接收（incoming）信号角色比较
num.link <- sapply(object.list, function(x) {rowSums(x@net$count) + colSums(x@net$count)-diag(x@net$count)})#计算互作数目
weight.MinMax <- c(min(num.link), max(num.link)) # 获取互作数目的最小值和最大值，用来标准化图形的点大小
#gg <- list()#新建一个空列表
for (i in 1:length(object.list)) {#绘制气泡图
  p <- netAnalysis_signalingRole_scatter(object.list[[i]], title = names(object.list)[i], weight.MinMax = weight.MinMax)
  ggsave(filename=paste0("05-",i, "_dotplot.pdf"), plot=p, width = 8, height = 8, units = 'in', dpi = 300)#保存图片
}
#patchwork::wrap_plots(plots = gg)
#对感兴趣细胞类型的信号通路变化进行分析
#gg1 <- netAnalysis_signalingChanges_scatter(cellchat, idents.use = "CD4 T")
#gg1
#两组信号通路差异分析
pdf(file="06deg.pdf",width=16,height=8)
gg1 <- rankNet(cellchat, mode = "comparison", stacked = T, do.stat = TRUE)
gg2 <- rankNet(cellchat, mode = "comparison", stacked = F, do.stat = TRUE)
gg1 + gg2
dev.off()
#发送（outgoing）和接收（incoming）信号通路比较
library(ComplexHeatmap)
i = 1
#合并所有数据集鉴定的信号通路 
pathway.union <- union(object.list[[i]]@netP$pathways, object.list[[i+1]]@netP$pathways)
ht1 = netAnalysis_signalingRole_heatmap(object.list[[i]], pattern = "outgoing", signaling = pathway.union, title = names(object.list)[i], width = 30, height = 25)#第一个对象热图
ht2 = netAnalysis_signalingRole_heatmap(object.list[[i+1]], pattern = "outgoing", signaling = pathway.union, title = names(object.list)[i+1], width = 30, height = 25)#第二个对象热图
pdf(file="07two.pdf",width=40,height=26)
draw(ht1 + ht2, ht_gap = unit(1, "cm"))#合并两个绘图对象
dev.off()
#配受体对差异分析
#netVisual_bubble(cellchat, sources.use = 4, targets.use = c(5:10),  comparison = c(1, 2), angle.x = 45)
#分别显示互作增加或减少
pdf(file="08interaction_deg.pdf",width=16,height=12)
gg1 <- netVisual_bubble(cellchat, sources.use = c(1:4,6:10), targets.use = 5,  comparison = c(1, 2), max.dataset = 2, title.name = "Increased signaling in treat", angle.x = 45, remove.isolate = T)#互作增加
gg2 <- netVisual_bubble(cellchat, sources.use = c(1:4,6:10), targets.use = 5,  comparison = c(1, 2), max.dataset = 1, title.name = "Decreased signaling in treat", angle.x = 45, remove.isolate = T)#互作减少
gg1 + gg2
dev.off()

pdf(file="08-2interaction_deg.pdf",width=16,height=12)
gg1 <- netVisual_bubble(cellchat, sources.use = 5, targets.use = c(1:4,6:10),  comparison = c(1, 2), max.dataset = 2, title.name = "Increased signaling in treat", angle.x = 45, remove.isolate = T)#互作增加
gg2 <- netVisual_bubble(cellchat, sources.use = 5, targets.use = c(1:4,6:10),  comparison = c(1, 2), max.dataset = 1, title.name = "Decreased signaling in treat", angle.x = 45, remove.isolate = T)#互作减少
gg1 + gg2
dev.off()

gg1$data#得到配受体对数据
gg2$data
#画基因表达
cellchat@meta$datasets = factor(cellchat@meta$datasets, levels = c("ctrl", "treat")) # 设置因子水平
pdf(file="09gene.pdf",width=16,height=8)
plotGeneExpression(cellchat, signaling = "CCL", split.by = "datasets", colors.ggplot = T)#画基因表达图
dev.off()
#保存rds文件
saveRDS(cellchat, file = "cellchat_comparisonAnalysis_pd_vs_hc.rds")

##########################################################15hdWGCNA-20240622
load("/home/server/data1/jyz/Ctrl_EcO/01RDada/06_scRNA_harmony_singler20240621.Rdata")

# 推荐本地安装
#devtools::install_local('hdWGNCA.zip')
#BiocManager::install('harmony',update=F,ask=F)
library(hdWGCNA)
#加载单细胞分析包
library(Seurat)
#加载作图包
library(tidyverse)
library(cowplot)
library(patchwork)
#加载共表达网络分析包
library(WGCNA)


# 读取单细胞数据集，读取自己的
scRNA_harmony<-scRNA_harmony_singler2

# 提上皮亚群,重新降维聚类
scRNA<-subset(scRNA_harmony,singleRnew=="Macrophage")
####需要对scRNA的metadata
scRNA@meta.data$orig.ident2<-scRNA@meta.data$orig.ident
scRNA@meta.data$orig.ident<-as.character(scRNA@meta.data$group)
scRNA@meta.data$celltype<-scRNA@meta.data$singleRnew

scRNA<- FindVariableFeatures(scRNA, selection.method = "vst", nfeatures = 2000)
scale.genes <-  VariableFeatures(scRNA)
scRNA <- ScaleData(scRNA, features = scale.genes)
scRNA<- RunPCA(scRNA, features = VariableFeatures(scRNA))
DimPlot(scRNA, reduction = "pca", group.by = "orig.ident")
ElbowPlot(scRNA)
scRNA <- FindNeighbors(scRNA, dims = 1:20)
scRNA <- FindClusters(scRNA,resolution=0.3)
scRNA <- RunUMAP(scRNA, dims = 1:20)
if (!dir.exists("15hdWGCNA")){
dir.create("15hdWGCNA")
}

setwd("./15hdWGCNA")#切换工作目录


#



# 瞄一眼，小亚群
pdf("01dimplot.pdf", height=10, width=18)
DimPlot(scRNA, label=TRUE) 
dev.off()
#过滤出至少在5%的细胞中表达的基因
scRNA <- SetupForWGCNA(
  scRNA,
  gene_select = "fraction", # the gene selection approach
  fraction = 0.05, # fraction of cells that a gene needs to be expressed in order to be included
  wgcna_name = "Bio_com" # the name of the hdWGCNA experiment
)


#构建metacells!!这一步非常重要，WGCNA对数据的稀疏性非常敏感，与普通转录组的WGCNA分析相比
# 单细胞的稀疏矩阵的解决方法是WGCNA流程的问题核心

# construct metacells  in each group
scRNA<- MetacellsByGroups(
  seurat_obj = scRNA,k=20,
  max_shared = 10,
  # group.by一般关注的是组织类型和细胞类型!这边组织类型是orig.ident，CT正常，PR疾病
  group.by = c("celltype",'orig.ident'), # 也可以选择别的groupby
  ident.group = 'celltype' # set the Idents of the metacell seurat object
)

# normalize metacell expression matrix:
scRNA <- NormalizeMetacells(scRNA)
metacell_obj <- GetMetacellObject(scRNA)


#转置表达矩阵
# 安全起见，另起一个对象，以角质细胞细胞为例
seurat_obj  <- SetDatExpr(
  scRNA,
  group_name = "Macrophage", # 选择感兴趣恶的细胞类群！
  group.by='celltype' # the metadata column containing the cell type info. This same column should have also been used in MetacellsByGroups
)


#选择softpower
seurat_obj <- TestSoftPowers(
  seurat_obj,
  setDatExpr = FALSE, # 这边不用转置了，前面已转置
)


# plot the results:
plot_list <- PlotSoftPowers(seurat_obj)
pdf("02wrap_plots.pdf", height=10, width=18)
wrap_plots(plot_list, ncol=2)
dev.off()
# assemble with patchwork




#查看powerTable
power_table <- GetPowerTable(seurat_obj)
head(power_table)


#构建共表达网络
softpower=8  # 根据自己的改，选5也没问题
# construct co-expression network:
seurat_obj <- ConstructNetwork(
  seurat_obj, soft_power=softpower,
  group.by='celltype', group_name='Macrophage',setDatExpr = F)


#可视化WGCNA网络

pdf("03Dendrogram_Plot.pdf", height=10, width=10)
PlotDendrogram(seurat_obj, main='hdWGCNA Dendrogram')
dev.off()

#(可选)获取TOM矩阵，可用来进行其他高级分析
TOM <- GetTOM(seurat_obj)


#计算模块协调特征
#记得scale一下 or else harmony throws an error:
seurat_obj <- Seurat::ScaleData(
  seurat_obj,
  features = GetWGCNAGenes(seurat_obj),
  
)
# 计算ME，根据组织类型分组
# harmony必须biocManager安装，不可以用github安装！！！
library(harmony)

seurat_obj <- ModuleEigengenes(
  seurat_obj,
  group.by.vars="orig.ident" #harmony对象
)


seurat_obj <- ModuleConnectivity(seurat_obj)
# plot genes ranked by kME for each module
#可视化每个模块中，按照kME打分的基因

pdf("04KME_Plot.pdf", height=10, width=30)
PlotKMEs(seurat_obj, ncol=3)
dev.off()




# 获取hub genes
hub_df <- GetHubGenes(seurat_obj, n_hubs = 25)
head(hub_df)
pdf("05KME_Plot.pdf", height=10, width=30)
PlotKMEs(seurat_obj)
dev.off()
#记得保存上面hdWGNCA关键分析过程！！！
saveRDS(seurat_obj, file='hdWGCNA_object.rds')




####------------一些可视化-----------------------
## 模块间的相关性
library(igraph)
library(qgraph)
# 载入保存的
#seurat_obj=readRDS('e:/writing/benke/hdWGCNA/hdWGCNA_object.rds')
# 画模块间相关性图
pdf("06ModuleCorrelogram_Plot.pdf", height=10, width=10)
ModuleCorrelogram(seurat_obj, sig.level = 0.001, pch.cex=2)
dev.off()
# 由于识别到了每个模块的hub基因，可以去计算hub基因打分
# compute gene scoring for the top 25 hub genes by kME for each module
# (方法一)with Seurat method------不用此方法
#seurat_obj <- ModuleExprScore(
#  seurat_obj,
#  n_genes = 25,
#  method='Seurat'
#)
# compute gene scoring for the top 25 hub genes by kME for each module
# (方法二)with UCell method #推荐这种方法
# 由于Ucell刚刚更新，所以4.1.x的同学请用本地安装,依赖包自行安装
#devtools::install_local("d:/R/UCell-1.3.zip")
library(UCell)
seurat_obj <- ModuleExprScore(
  seurat_obj,
  n_genes = 25,
  method='UCell'
)

# featureplot
# 瞄一眼
pdf("07featureplot.pdf", height=10, width=10)
DimPlot(scRNA, label=TRUE,split.by = 'orig.ident') 
dev.off()


plot_list <- ModuleFeaturePlot(
  seurat_obj,
  features='hMEs', # plot the hMEs
  order=TRUE ,# order so the points with highest hMEs are on top
)

# stitch together with patchwork
pdf("08plot_list.pdf", height=10, width=10)
wrap_plots(plot_list)
dev.off()

### dotplot
# get hMEs from seurat object
MEs <- GetMEs(seurat_obj, harmonized=TRUE)
mods <- colnames(MEs)
mods <- mods[mods != 'grey']

# add hMEs to Seurat meta-data:
seurat_obj@meta.data <- cbind(seurat_obj@meta.data, MEs)

# plot with Seurat's DotPlot function
p <- DotPlot(seurat_obj, features=mods)

# flip the x/y axes, rotate the axis labels, and change color scheme:
p <- p +
  coord_flip() +
  RotatedAxis() +
  scale_color_gradient2(high='red', mid='grey95', low='blue')

# plot output

pdf("09output_plot.pdf", height=10, width=10)
p
dev.off()
######公众号缺少了一部分
seurat_obj$orig.ident<-as.factor(seurat_obj$orig.ident)
cur_traits <- c('orig.ident','nCount_RNA')

seurat_obj <- ModuleTraitCorrelation(
  seurat_obj,
  traits = cur_traits,
  features = "hMEs",
  cor_method = "pearson",
  group.by='orig.ident'
)
mt_cor <- GetModuleTraitCorrelation(seurat_obj)
names(mt_cor)
pdf("09tModuleTraitCorrelation_plot.pdf", height=10, width=10)
PlotModuleTraitCorrelation(
  seurat_obj,
  label = 'fdr',
   label_symbol = 'stars',
    text_size = 2,
  text_digits = 2,
  text_color = 'white',
  high_color = '#fc9272',
   mid_color = '#ffffbf',
   low_color = '#9ecae1',
   plot_max = 0.2,
  combine=T 
  )
dev.off()
######################################第三节
#单细胞也能实现WGCNA分析！快来学习hdWGCNA！（三）hdWGCNA配套富集/网络可视化大放送！（三）

#加载seurat数据和包
# single-cell analysis package
##setwd('e:/writing/benke/hdWGCNA/')
library(Seurat)

# plotting and data science packages
library(tidyverse)
library(cowplot)
library(patchwork)

# co-expression network analysis packages:
library(WGCNA)
library(hdWGCNA)

# gene enrichment packages
#install.packages('enrichR')
library(enrichR)

#BiocManager::install('GeneOverlap',update = F,ask = F)
library(GeneOverlap)

# using the cowplot theme for ggplot
theme_set(theme_cowplot())

# set random seed for reproducibility
#set.seed(12345)

# load the Zhou et al snRNA-seq dataset
#seurat_obj <- readRDS('hdWGCNA_object.rds')

#GO富集分析
# enrichr databases to test
dbs <- c('GO_Biological_Process_2021','GO_Cellular_Component_2021','GO_Molecular_Function_2021')

# 富集分析，会逐个模块分析
seurat_obj <- RunEnrichr(
  seurat_obj,
  dbs=dbs, # character vector of enrichr databases to test
  max_genes = 100 # number of genes per module to test
)

# retrieve the output table
enrich_df <- GetEnrichrTable(seurat_obj)

# make GO term plots作图，在文件夹下生成！
pdf("10EnrichrBarPlot.pdf", height=10, width=10)


EnrichrBarPlot(
  seurat_obj,
  outdir = "enrichr_plots", # name of output directory
  n_terms = 10, # number of enriched terms to show (sometimes more show if there are ties!!!)
  plot_size = c(5,7), # width, height of the output .pdfs
  logscale=TRUE # do you want to show the enrichment as a log scale?
)
dev.off()
#气泡图
# GO_Biological_Process_2021
pdf("11EnrichrBarPlot.pdf", height=10, width=10)
EnrichrDotPlot(
  seurat_obj,
  mods = c("turquoise","black"), # use all modules (this is the default behavior)
  database = "GO_Biological_Process_2021", # this has to be one of the lists we used above!!!
  n_terms=6
  # number of terms for each module
)
dev.off()

#气泡图
# GO_Cellular_Component_2021
pdf("12EnrichrBarPlot.pdf", height=10, width=10)
EnrichrDotPlot(
  seurat_obj,
  mods = c("turquoise","black",'blue'), # use all modules (this is the default behavior)
  database = "GO_Cellular_Component_2021", # this has to be one of the lists we used above!!!
  n_terms=6
  # number of terms for each module
)
dev.off()
#气泡图
# GO_Biological_Process_2021

pdf("13EnrichrBarPlot.pdf", height=10, width=10)
EnrichrDotPlot(
  seurat_obj,
  mods = c("turquoise","black",'red'), # use all modules (this is the default behavior)
  database = "GO_Molecular_Function_2021", # this has to be one of the lists we used above!!!
  n_terms=6
  # number of terms for each module
)

dev.off()
#差异基因重叠分析
## 这个分析帮助我们看到，哪些模块可能是相似的
# compute cell-type marker genes with Seurat:
# 常规方法计算差异基因/特征基因
Idents(seurat_obj) <- seurat_obj$seurat_clusters
markers <- Seurat::FindAllMarkers(
  seurat_obj,
  only.pos = TRUE,
  logfc.threshold=1
)

# compute marker gene overlaps
overlap_df <- OverlapModulesDEGs(
  seurat_obj,
  deg_df = markers,
  fc_cutoff = 1 # log fold change cutoff for overlap analysis
)

#条形图
# overlap barplot, produces a plot for each cell type
plot_list <- OverlapBarPlot(overlap_df)

# stitch plots with patchwork


pdf("14OverlapBarPlot.pdf", height=10, width=40)
wrap_plots(plot_list, ncol=4)
dev.off()
#气泡图
# plot odds ratio of the overlap as a dot plot
pdf("15OverlapBarPlot.pdf", height=10, width=10)
OverlapDotPlot(
  overlap_df,
  plot_var = 'odds_ratio') +
  ggtitle('Overlap of modules & cell-type markers')
dev.off()
#----------------------------
#网络可视化
# network analysis & visualization package:
# network analysis & visualization package:
library(igraph)

#可视化每个模块的网络图
pdf("16ModuleNetworkPlot.pdf", height=10, width=10)
ModuleNetworkPlot(seurat_obj)
dev.off()
#组合网络图，在文件夹下生成
# hubgene network
pdf("17ModuleNetworkPlot.pdf", height=10, width=10)
HubGeneNetworkPlot(
  seurat_obj,
  n_hubs = 3, n_other=5,
  edge_prop = 0.75,
  mods = "all"
)

dev.off()
#UMAP可视化
## 利用hub基因，重新UMAP，如此可以获得分群明显的图
g <- HubGeneNetworkPlot(seurat_obj,  return_graph=TRUE)

seurat_obj <- RunModuleUMAP(
  seurat_obj,
  n_hubs = 10, # number of hub genes to include for the UMAP embedding
  n_neighbors=15, # neighbors parameter for UMAP
  min_dist=0.1 # min distance between points in UMAP space
)


# get the hub gene UMAP table from the seurat object
umap_df <- GetModuleUMAP(seurat_obj)

# plot with ggplot
pdf("18ggplot.pdf", height=10, width=10)
ggplot(umap_df, aes(x=UMAP1, y=UMAP2)) +
  geom_point(
    color=umap_df$color, # color each point by WGCNA module
    size=umap_df$kME*2 # size of each point based on intramodular connectivity
  ) +
  umap_theme()
dev.off()
pdf("19ggplot.pdf", height=10, width=10)
ModuleUMAPPlot(
  seurat_obj,
  edge.alpha=0.25,
  sample_edges=TRUE,
  edge_prop=0.1, # proportion of edges to sample (20% here)
  label_hubs=2 ,# how many hub genes to plot per module?
  keep_grey_edges=FALSE

)
dev.off()
#监督UMAP
g <- ModuleUMAPPlot(seurat_obj,  return_graph=TRUE)
# run supervised UMAP:
seurat_obj <- RunModuleUMAP(
  seurat_obj,
  n_hubs = 10,
  n_neighbors=15,
  min_dist=0.1,
  supervised=TRUE,
  target_weight=0.5
)

# get the hub gene UMAP table from the seurat object
umap_df <- GetModuleUMAP(seurat_obj)

# plot with ggplot
pdf("20ggplot.pdf", height=10, width=10)
ggplot(umap_df, aes(x=UMAP1, y=UMAP2)) +
  geom_point(
    color=umap_df$color, # color each point by WGCNA module
    size=umap_df$kME*2 # size of each point based on intramodular connectivity
  ) +
  umap_theme()

dev.off()
rm scRNA_harmony_singler2
rm scRNA_harmony
save.image(file="20240622hdWGCNA.RData")

##################################################################16巨噬细胞粒细胞重新分组
setwd("/home/server/data1/jyz/Ctrl_EcO/")#切换工作目录
load("/home/server/data1/jyz/Ctrl_EcO/01RDada/06_scRNA_harmony_singler20240621.Rdata")

if (!dir.exists("16Macrophage_regroup")){
dir.create("16Macrophage_regroup")
}

setwd("./16Macrophage_regroup")#切换工作目录
library(Seurat)
#加载作图包
library(tidyverse)
library(cowplot)
library(patchwork)
library(clustree)




# 提取Macrophage细胞亚群,重新降维聚类
scRNA<-subset(scRNA_harmony_singler2,singleRnew=="Macrophage")
####需要对scRNA的metadata
scRNA@meta.data$orig.ident2<-scRNA@meta.data$orig.ident
scRNA@meta.data$orig.ident<-as.character(scRNA@meta.data$group)
scRNA@meta.data$celltype<-scRNA@meta.data$singleRnew

scRNA<- NormalizeData(scRNA, selection.method = "vst", nfeatures = 2000)
scRNA<- FindVariableFeatures(scRNA)
scale.genes <-  VariableFeatures(scRNA)
scRNA <- ScaleData(scRNA, features = scale.genes)
scRNA<- RunPCA(scRNA, features = VariableFeatures(scRNA))
library(harmony)
scRNA_harmony <- RunHarmony(scRNA, group.by.vars = "orig.ident2")
DimPlot(scRNA, reduction = "pca", group.by = "orig.ident2")
ElbowPlot(scRNA)
scRNA <- FindNeighbors(scRNA, reduction = "harmony",dims = 1:20)
scRNA <- FindClusters(scRNA,resolution=c(seq(0.1,0.5,0.1)))
pdf("01resolution_clustree.pdf", height=10, width=10)
clustree(scRNA@meta.data,prefix="RNA_snn_res.")
dev.off()
scRNA <- FindClusters(scRNA,resolution=0.3)
scRNA <- RunUMAP(scRNA, reduction = "harmony",dims = 1:20)

###采用张泽民团队的ROGUE分析细胞亚群的纯度
library(ROGUE)

ent.res <- SE_fun(scRNA@assays$RNA@counts)
rogue.value <- CalculateRogue(ent.res, platform = "UMI")
rogue.value
####################注意一下，表达矩阵用counts,labels就是不同分辨率分出的亚型，samples是不同的样本，可能要考虑不同样本来源
####################画图时挑选相近的几个分辨率画图。
rogue.res0.2 <- rogue(scRNA@assays$RNA@counts, labels = scRNA@meta.data$RNA_snn_res.0.2, samples = scRNA@meta.data$orig.ident2, platform = "UMI", span = 0.6)
pdf("02-1-02rogue_boxplot.pdf", height=10, width=10)
rogue.boxplot(rogue.res0.2)
dev.off()
rogue.res0.3 <- rogue(scRNA@assays$RNA@counts, labels = scRNA@meta.data$RNA_snn_res.0.3, samples = scRNA@meta.data$orig.ident2, platform = "UMI", span = 0.6)
pdf("02-2-03rogue_boxplot.pdf", height=10, width=10)
rogue.boxplot(rogue.res0.3)
dev.off()

rogue.res0.4 <- rogue(scRNA@assays$RNA@counts, labels = scRNA@meta.data$RNA_snn_res.0.4, samples = scRNA@meta.data$orig.ident2, platform = "UMI", span = 0.6)
pdf("02-3-04rogue_boxplot.pdf", height=10, width=10)
rogue.boxplot(rogue.res0.4)
dev.off()




#绘制UMAP
pdf(file="03-0Macrophage_regroup_UMAP.pdf")
DimPlot(scRNA, reduction = 'umap')
dev.off()
pdf(file="03-1Macrophage_regroup_UMAP.pdf")
DimPlot(scRNA, reduction = 'umap',group.by="orig.ident")
dev.off()
pdf(file="03-2Macrophage_regroup_UMAP.pdf")
DimPlot(scRNA, reduction = 'umap',split.by="orig.ident2")
dev.off()
pdf(file="03-03Macrophage_regroup_UMAP-CCL5.pdf")
FeaturePlot(scRNA, features = c("CCL5"), split.by = "orig.ident")
dev.off()
pdf(file="03-04Macrophage_regroup_UMAP-CCL5.pdf")
FeaturePlot(scRNA, features = c("CCL5"), split.by = "orig.ident2")
dev.off()

#鉴定新亚群各自的marker基因
scRNA.markers <- FindAllMarkers(scRNA, 
                                only.pos = TRUE,  #特异性高表达marker
                                min.pct = 0.25, 
                                logfc.threshold = 0.25
)

#保存每个亚群top5 marker基因
top5 <- scRNA.markers %>% group_by(cluster) %>% top_n(n = 5, wt = avg_log2FC) 
write.csv(file="Macrophage_top5_cell_markers.csv",top5)


top5_gene=top5$gene
#violin plot
pdf(file="04Macrophage_violin_marker.pdf",width=10)
VlnPlot(scRNA, features = top5_gene)
dev.off()


#dotplot
pdf(file="05Macrophage_dotplot_marker.pdf",width=10)
DotPlot(scRNA,features = top5_gene)+ RotatedAxis()
dev.off()

#ridgeplot
pdf(file="06Macrophage_ridgeplot_marker.pdf",width=120,height=90)
RidgePlot(scRNA, features = top5_gene)
dev.off()

#feature plot
pdf(file="07Macrophage_featureplot_marker.pdf",width=10)
FeaturePlot(scRNA, features = top5_gene)
dev.off()


#heatmap
pdf('08Macrophage_cluster_heatmap.pdf', width=15,height=10)
DoHeatmap(scRNA, features = top5_gene) + NoLegend()
dev.off()
scRNA_harmony_Macrophage_regroup<-scRNA 
save(scRNA_harmony_Macrophage_regroup,file="scRNA_harmony_Macrophage_regroup.Rdata")



###############################################细分亚群的细胞

#install.packages("ggplot2")
#install.packages("ggalluvial")


library(ggalluvial)
library(ggplot2)
library(dplyr)

#inputFile="input.txt"         
outFile="09scRNA_harmony_Stromal_regroup_ggalluvial.pdf"    
rt<-data.frame(orig.ident=scRNA_harmony_Stromal_regroup@meta.data$orig.ident2,celltype=scRNA_harmony_Stromal_regroup@meta.data$RNA_snn_res.0.3,group=scRNA_harmony_Stromal_regroup@meta.data$group)
#rt=read.table(inputFile, header = T, sep="\t", check.names=F)     
corLodes=to_lodes_form(rt, axes = 1:ncol(rt), id = "Cohort")

#得到输出文件
pdf(file=outFile,width=8,height=6)
#ident_colours = ["#F8766D", "#E68613", "#ABA300", "#0CB702", "#00C19A","#00BFC4","#00A9FF","#8494FF", "#C77CFF", "#ED68ED"]
mycol <- c("#F8766D", "#E68613", "#ABA300", "#0CB702", "#00C19A", "#00BFC4", "#00A9FF", "#8494FF", "#C77CFF", "#ED68ED")
ggplot(corLodes, aes(x = x, stratum = stratum, alluvium = Cohort,fill = stratum, label = stratum)) +
  	 scale_x_discrete(expand = c(0, 0)) +  
  	 #用aes.flow控制线调颜色，forward说明颜色和前面一致，backward说明与后面一致
  	 geom_flow(width = 2/10,aes.flow = "forward") + 
	 geom_stratum(alpha = .9,width = 2/10) +
	 scale_fill_manual(values = mycol) +
	 #size = 2代表基因名字大小
	 geom_text(stat = "stratum", size = 2,color="black") +
	 xlab("") + ylab("") + theme_bw() + 
	 theme(axis.line = element_blank(),axis.ticks = element_blank(),axis.text.y = element_blank()) + 
	 theme(panel.grid =element_blank()) + 
	 theme(panel.border = element_blank()) + 
	 ggtitle("") + guides(fill = FALSE)                            
dev.off()




scRNA1<-scRNA_harmony_Stromal_regroup
scRNA1@meta.data$celltype<-scRNA1@meta.data$RNA_snn_res.0.3
x=scRNA1@meta.data$celltype
table(x)
pB2_df <- table(scRNA1@meta.data$celltype,scRNA1@meta.data$orig.ident) %>% melt()
colnames(pB2_df) <- c("Cluster","Sample","Number")
cluster=c("cluster_0","cluster_1","cluster_2","cluster_3","cluster_4","cluster_5","cluster_6","cluster_7","cluster_8","cluster_9")
cluster2<-c(cluster,cluster)
pB2_df$Cluster<-cluseter2
pB2_df$Cluster <- factor(pB2_df$Cluster,levels = cluster)
library(RColorBrewer)
sample_color <- c("#F8766D", "#E68613", "#ABA300", "#0CB702", "#00C19A", "#00BFC4", "#00A9FF", "#8494FF", "#C77CFF", "#ED68ED")

pB4 <- ggplot(data = pB2_df, aes(x =Number, y = Sample, fill =  Cluster)) +
  geom_bar(stat = "identity", width=0.8,position="fill")+
  scale_fill_manual(values=sample_color) +
  theme_bw()+
  theme(panel.grid =element_blank()) +
  labs(x="",y="Ratio")+
  ####用来将y轴移动位置
  theme(axis.text.y = element_text(size=12, colour = "black"))+
  theme(axis.text.x = element_text(size=12, colour = "black"))
pB4
ggsave("03-sample-ratio-new.pdf",width = 16,height = 8,units = "cm")
























#####细分亚群的GSVA
library(Seurat)
library(msigdbr)
library(GSVA)
library(tidyverse)
library(clusterProfiler)
library(patchwork)
library(fgsea)
library(dplyr)
library(ggplot2)
#load('scRNA_harmony.Rdata')

#####样本分组和细胞信息联合起来，变成新的分组信息

#scRNA_harmony@meta.data$newgroup<-as.factor(paste0(scRNA_harmony@meta.data$group,"_",scRNA_harmony@meta.data$singleRnew))
#获取细胞类型
scRNA<-scRNA_harmony_Stromal_regroup
Idents(scRNA)<-scRNA@meta.data$RNA_snn_res.0.3
#计算每个基因在每个细胞亚群中的平均表达值
expr <- AverageExpression(scRNA, assays = "RNA", slot = "data")[[1]]
#View(expr)
#选取非零基因
expr <- expr[rowSums(expr)>0,] 
#转换成矩阵
expr <- as.matrix(expr)


#从GSEA官网下载GSEA分析需要的基因集
#http://www.gsea-msigdb.org/gsea/index.jsp

#下载免疫相关的基因集，h: hallmark gene sets
gmtfile ='/public/workspace/lincs/me/yao/mh.all.v2023.2.Mm.symbols.gmt'

#读取gmt文件中的pathway信息
pathway<-read.gmt(gmtfile)[,c(2,1)]
#去堆叠,转换成list
genesets=unstack(pathway)

#进行GSVA分析
gsva.res <- gsva(expr, genesets, method="ssgsea") 
#保存GSVA分析结果
gsva.df <- data.frame(Genesets=rownames(gsva.res), gsva.res, check.names = F)
write.csv(gsva.df, "10Stromal_regroup_gsva_res.csv", row.names = F)

#绘制热图
library(pheatmap)
pdf(file="10Stromal_regroup_GSVA_heatmap.pdf",width=12,height=8)
pheatmap(gsva.res, show_colnames = T, scale = "row")
dev.off()





####################################################################monocle2---跑了
rm(list=ls())
library(Seurat)
library(monocle)
library(dplyr)

#加载单个样本单细胞数据分析的结果
#load(file="scRNA_harmony_Stromal_regroup.Rdata")
###############################
#将seurat对象转换成monocle对象
##############################写于2024年01月03日，以后再遇到RNA速率时barcode出现问题时采用下列代码
#####查看loom文件细胞名的命名，采用RNA速率时的那边代码，发现是  m-out: +16位barcode +x
#而在scRNA_harmony_Stromal_regroup还有-1_1 和-1_2之类的
#因此需要将这个barcode处理成那样，还走了弯路，直接colnames(scRNA_harmony_Stromal_regroup)<-aaa不行，后来查了相关的github，有个专门的函数

a<-paste0(tolower(scRNA_harmony_Stromal_regroup@meta.data$orig.ident),"-out:",colnames(scRNA_harmony_Stromal_regroup),"x")
head(a)
aa<-gsub("-1_1","",a)
aaa<-gsub("-1_2","",aa)
head(aaa)
###报错！！！！colnames(scRNA_harmony_Stromal_regroup)<-aaa

scRNA_harmony_Stromal_regroup2<-RenameCells(scRNA_harmony_Stromal_regroup,new.names=aaa)
save(scRNA_harmony_Stromal_regroup2,file="scRNA_harmony_Stromal_regroup_rename.Rdata")



scRNA<-scRNA_harmony_Stromal_regroup2
scRNA$celltype <- Idents(scRNA)
data <- scRNA[['RNA']]@data
pd <- new('AnnotatedDataFrame', data = scRNA@meta.data)
fData <- data.frame(gene_short_name = row.names(data), row.names = row.names(data))
fd <- new('AnnotatedDataFrame', data = fData)
HSMM <- newCellDataSet(data,
                       phenoData = pd,
                       featureData = fd
                       )

#########################
#构建细胞发育轨迹
#########################
ordering_genes <- scRNA[["RNA"]]@var.features
HSMM <- setOrderingFilter(HSMM, ordering_genes)
HSMM <- estimateSizeFactors(HSMM)
#降维
HSMM <- reduceDimension(HSMM,
                        norm_method="none", 
                        reduction_method="DDRTree",
                        max_components=3,
                        scaling=TRUE,
                        verbose=TRUE,
                        pseudo_expr=0)

#将细胞摆放到轨迹上
HSMM <- orderCells(HSMM)
save(HSMM,file="scRNA_harmony_Stromal_regroup_HSMM_monocle.Rdata")
#绘图展示
#以state来展示
pdf('11Stromal_regroup_trajectory_state.pdf')
plot_cell_trajectory(HSMM)
dev.off()

#以细胞类型来展示
pdf('12Stromal_regroup_trajectory_celltype.pdf')
plot_cell_trajectory(HSMM, color_by = 'celltype') 
dev.off()

#分别展示每一个细胞类型的发育轨迹
pdf('13Stromal_regroup_trajectory_celltype_separate.pdf')
plot_cell_trajectory(HSMM, color_by = 'celltype')+ facet_wrap(~celltype, nrow = 3) + NoLegend()
dev.off()

#查看特定的gene在发育轨迹上的表达情况
pdf("14Stromal_regroup_5gene_trajectory.pdf",width=12)
plot_cell_trajectory(HSMM,markers=c("Il33","Il1b","Il6"),use_color_gradient=T)
dev.off()


#heatmap
scRNA.markers <- FindAllMarkers(scRNA, 
                                only.pos = TRUE,  #特异性高表达marker
                                min.pct = 0.25, 
                                logfc.threshold = 0.25
)
top5=scRNA.markers %>% group_by(cluster) %>% top_n(n = 5, wt = avg_log2FC)
sig_gene_names <- unique(top5$gene)

###以下运行出问题

HSMM2 <- BEAM(HSMM, branch_point = 1, cores = 8)



pseudotemporalplot<- plot_pseudotime_heatmap(HSMM2[sig_gene_names,],
                                             num_clusters = 3,  #亚群数需要对应修改
                                             cores = 1,
                                             hmcols = NULL,
                                             show_rownames = T,
                                             return_heatmap = T)
pdf(file="15tumor_monocle_heatmap.pdf")
pseudotemporalplot
dev.off()

#####################下面是华哥的monocle2代码
scRNA<-scRNA_harmony_Neutrophils_regroup
scRNA$celltype <- Idents(scRNA)
data <- scRNA[['RNA']]@data
pd <- new('AnnotatedDataFrame', data = scRNA@meta.data)
fData <- data.frame(gene_short_name = row.names(data), row.names = row.names(data))
fd <- new('AnnotatedDataFrame', data = fData)

monocle_cds <- newCellDataSet(data,
                              phenoData = pd,
                              featureData = fd,
                              lowerDetectionLimit = 0.5,
                              expressionFamily = negbinomial.size())



monocle_cds <- estimateSizeFactors(monocle_cds)
monocle_cds <- estimateDispersions(monocle_cds)

monocle_cds <- detectGenes(monocle_cds, min_expr = 0.1)
print(head(fData(monocle_cds)))

HSMM=monocle_cds
disp_table <- dispersionTable(HSMM)
disp.genes <- subset(disp_table, mean_expression >= 0.1 & dispersion_empirical >= 1 * dispersion_fit)$gene_id
HSMM <- setOrderingFilter(HSMM, disp.genes)
plot_ordering_genes(HSMM)


HSMM <- reduceDimension(HSMM, max_components = 2,
                        method = 'DDRTree')


HSMM <- orderCells(HSMM)
plot_cell_trajectory(HSMM, color_by = "seurat_clusters")


plot_cell_trajectory(HSMM, color_by = "State")

plot_cell_trajectory(HSMM, color_by = "Pseudotime")

plot_cell_trajectory(HSMM, color_by = "celltype")
plot_cell_trajectory(HSMM, color_by = "State") +
  facet_wrap(~State, nrow = 3)



blast_genes <- row.names(subset(fData(HSMM),
                                gene_short_name %in% c("GAPDH", "RORA")))
plot_genes_jitter(HSMM[blast_genes,],
                  grouping = "State",
                  min_expr = 0.1)



HSMM_expressed_genes <-  row.names(subset(fData(HSMM),
                                          num_cells_expressed >= 10))
HSMM_filtered <- HSMM[HSMM_expressed_genes,]
my_genes <- row.names(subset(fData(HSMM_filtered),
                             gene_short_name %in% c("YWHAB", "GAPDH", "TNNC1")))
cds_subset <- HSMM_filtered[my_genes,]
plot_genes_in_pseudotime(cds_subset, color_by = "seurat_clusters")



plot_genes_in_pseudotime(cds_subset, color_by =  "State")
plot_genes_in_pseudotime(cds_subset, color_by =  "celltype")



genes <- c("TNNT2", "TNNC1", "CDK1")
p1 <- plot_genes_jitter(HSMM[genes,], grouping = "State", color_by = "State")
p2 <- plot_genes_violin(HSMM[genes,], grouping = "State", color_by = "State")
p3 <- plot_genes_in_pseudotime(HSMM[genes,], color_by = "State")
plotc <- p1|p2|p3


to_be_tested <- row.names(subset(fData(HSMM),
                                 gene_short_name %in% c("MYH3", "MEF2C", "CCNB2", "TNNT1")))
cds_subset <- HSMM[to_be_tested,]

diff_test_res <- differentialGeneTest(cds_subset,
                                      fullModelFormulaStr = "~sm.ns(Pseudotime)")

diff_test_res[,c("gene_short_name", "pval", "qval")]
plot_genes_in_pseudotime(cds_subset, color_by ="State")




marker_genes <- row.names(subset(fData(HSMM),
                                 gene_short_name %in% c("MEF2C", "MEF2D", "MYF5",
                                                        "ANPEP", "PDGFRA","MYOG",
                                                        "TPM1",  "TPM2",  "MYH2",
                                                        "MYH3",  "NCAM1", "TNNT1",
                                                        "TNNT2", "TNNC1", "CDK1",
                                                        "CDK2",  "CCNB1", "CCNB2",
                                                        "CCND1", "CCNA1", "ID1")))

diff_test_res <- differentialGeneTest(HSMM[marker_genes,],
                                      fullModelFormulaStr = "~sm.ns(Pseudotime)")
sig_gene_names <- row.names(subset(diff_test_res, qval < 0.1))
plot_pseudotime_heatmap(HSMM[sig_gene_names,],
                        num_clusters = 3,
                        cores = 1,
                        show_rownames = T)






plot_cell_trajectory(HSMM, color_by = "State")


BEAM_res <- BEAM(HSMM, branch_point = 1, cores = 7)
BEAM_res <- BEAM_res[order(BEAM_res$qval),]
BEAM_res <- BEAM_res[,c("gene_short_name", "pval", "qval")]
plot_genes_branched_heatmap(HSMM[row.names(subset(BEAM_res,
                                                  qval < 1e-4)),],
                            branch_point = 1,
                            num_clusters = 4,
                            cores = 1,
                            use_gene_short_name = T,
                            show_rownames = T)


genes <- row.names(subset(fData(HSMM),
                          gene_short_name %in% c( "MEF2C", "CCNB2", "TNNT1")))

plot_genes_branched_pseudotime(HSMM[genes,],
                               branch_point = 1,
                               color_by = "State",
                               ncol = 1)






###############################以上测试有用，但图片没用保存。需要修改20221110
##系统报错改为英文
Sys.setenv(LANGUAGE = "en")
##禁止转化为因子
options(stringsAsFactors = FALSE)
##清空环境
rm(list=ls())

setwd("D:/shangke/lession17/")
load("scRNA_harmony.Rdata")
library(dplyr)
library(Seurat)
library(tidyverse)
library(patchwork)
library(SingleR)
load("D:/ref.data/ref_Human_all.RData")



library(SingleR)
load("D:/ref.data/ref_Human_all.RData")

refdata <- ref_Human_all

testdata <- GetAssayData(scRNA_harmony, slot="data")
###把scRNA数据中的seurat_clusters提取出来，注意这里是因子类型的
clusters <- scRNA_harmony@meta.data$seurat_clusters
###开始用singler分析
cellpred <- SingleR(test = testdata, ref = refdata, labels = refdata$label.main, 
                    method = "cluster", clusters = clusters, 
                    assay.type.test = "logcounts", assay.type.ref = "logcounts")

celltype = data.frame(ClusterID=rownames(cellpred), celltype=cellpred$labels, stringsAsFactors = FALSE)
scRNA_harmony@meta.data$celltype = "NA"
for(i in 1:nrow(celltype)){
  scRNA_harmony@meta.data[which(scRNA_harmony@meta.data$seurat_clusters == celltype$ClusterID[i]),'celltype'] <- celltype$celltype[i]}

table(scRNA_harmony@meta.data$celltype)
table(scRNA_harmony@meta.data$seurat_clusters)
sc.t=scRNA_harmony[,rownames(subset(scRNA_harmony@meta.data,celltype=="T_cells"))]  



library(monocle)

scRNA.Osteoclastic=subset(scRNA_harmony,ident=c(0,1))
data <- as(as.matrix(scRNA.Osteoclastic@assays$RNA@counts), 'sparseMatrix')
?new
pd <- new('AnnotatedDataFrame', data = scRNA.Osteoclastic@meta.data)
fData <- data.frame(gene_short_name = row.names(data), row.names = row.names(data))
fd <- new('AnnotatedDataFrame', data = fData)
monocle_cds <- newCellDataSet(data,
                              phenoData = pd,
                              featureData = fd,
                              lowerDetectionLimit = 0.5,
                              expressionFamily = negbinomial.size())



monocle_cds <- estimateSizeFactors(monocle_cds)
monocle_cds <- estimateDispersions(monocle_cds)

monocle_cds <- detectGenes(monocle_cds, min_expr = 0.1)
print(head(fData(monocle_cds)))

HSMM=monocle_cds
disp_table <- dispersionTable(HSMM)
disp.genes <- subset(disp_table, mean_expression >= 0.1 & dispersion_empirical >= 1 * dispersion_fit)$gene_id
HSMM <- setOrderingFilter(HSMM, disp.genes)
plot_ordering_genes(HSMM)


HSMM <- reduceDimension(HSMM, max_components = 2,
                        method = 'DDRTree')


HSMM <- orderCells(HSMM)
plot_cell_trajectory(HSMM, color_by = "seurat_clusters")


plot_cell_trajectory(HSMM, color_by = "State")

plot_cell_trajectory(HSMM, color_by = "Pseudotime")

plot_cell_trajectory(HSMM, color_by = "celltype")
plot_cell_trajectory(HSMM, color_by = "State") +
  facet_wrap(~State, nrow = 3)



blast_genes <- row.names(subset(fData(HSMM),
                                gene_short_name %in% c("GAPDH", "RORA")))
plot_genes_jitter(HSMM[blast_genes,],
                  grouping = "State",
                  min_expr = 0.1)



HSMM_expressed_genes <-  row.names(subset(fData(HSMM),
                                          num_cells_expressed >= 10))
HSMM_filtered <- HSMM[HSMM_expressed_genes,]
my_genes <- row.names(subset(fData(HSMM_filtered),
                             gene_short_name %in% c("YWHAB", "GAPDH", "TNNC1")))
cds_subset <- HSMM_filtered[my_genes,]
plot_genes_in_pseudotime(cds_subset, color_by = "seurat_clusters")



plot_genes_in_pseudotime(cds_subset, color_by =  "State")
plot_genes_in_pseudotime(cds_subset, color_by =  "celltype")



genes <- c("TNNT2", "TNNC1", "CDK1")
p1 <- plot_genes_jitter(HSMM[genes,], grouping = "State", color_by = "State")
p2 <- plot_genes_violin(HSMM[genes,], grouping = "State", color_by = "State")
p3 <- plot_genes_in_pseudotime(HSMM[genes,], color_by = "State")
plotc <- p1|p2|p3


to_be_tested <- row.names(subset(fData(HSMM),
                                 gene_short_name %in% c("MYH3", "MEF2C", "CCNB2", "TNNT1")))
cds_subset <- HSMM[to_be_tested,]

diff_test_res <- differentialGeneTest(cds_subset,
                                      fullModelFormulaStr = "~sm.ns(Pseudotime)")

diff_test_res[,c("gene_short_name", "pval", "qval")]
plot_genes_in_pseudotime(cds_subset, color_by ="State")




marker_genes <- row.names(subset(fData(HSMM),
                                 gene_short_name %in% c("MEF2C", "MEF2D", "MYF5",
                                                        "ANPEP", "PDGFRA","MYOG",
                                                        "TPM1",  "TPM2",  "MYH2",
                                                        "MYH3",  "NCAM1", "TNNT1",
                                                        "TNNT2", "TNNC1", "CDK1",
                                                        "CDK2",  "CCNB1", "CCNB2",
                                                        "CCND1", "CCNA1", "ID1")))

diff_test_res <- differentialGeneTest(HSMM[marker_genes,],
                                      fullModelFormulaStr = "~sm.ns(Pseudotime)")
sig_gene_names <- row.names(subset(diff_test_res, qval < 0.1))
plot_pseudotime_heatmap(HSMM[sig_gene_names,],
                        num_clusters = 3,
                        cores = 1,
                        show_rownames = T)






plot_cell_trajectory(HSMM, color_by = "State")


BEAM_res <- BEAM(HSMM, branch_point = 1, cores = 7)
BEAM_res <- BEAM_res[order(BEAM_res$qval),]
BEAM_res <- BEAM_res[,c("gene_short_name", "pval", "qval")]
plot_genes_branched_heatmap(HSMM[row.names(subset(BEAM_res,
                                                  qval < 1e-4)),],
                            branch_point = 1,
                            num_clusters = 4,
                            cores = 1,
                            use_gene_short_name = T,
                            show_rownames = T)


genes <- row.names(subset(fData(HSMM),
                          gene_short_name %in% c( "MEF2C", "CCNB2", "TNNT1")))

plot_genes_branched_pseudotime(HSMM[genes,],
                               branch_point = 1,
                               color_by = "State",
                               ncol = 1)











####################################################RNA速率，需要继承上面的monocle结果
####首先需要做的是合并loom文件，涉及的loom很多，合并方法如下，另开窗口进行
##首先把需要的loom拷贝到/public/workspace/lincs/lab7/oral/new20221004/17rna_velo/目录下
#整合loom文件和meta-data数据
#代码中有对loom文件barcode的处理，与seurat的barcode一致。
cd /public/workspace/lincs/lab7/singlecell/scVelo/
singularity shell scvelo_python_20220525.sif
cd /public/workspace/lincs/me/yao/17rna_velo/
python




# 整合多个loom文件
import loompy
##本例中不需要整合
files=['m-out.loom','t-out.loom']
output_filename='combined.loom'
loompy.combine(files, output_filename, key="Accession")


setwd("/public/workspace/lincs/me/yao/")
if (!dir.exists("17rna_velo")){
dir.create("17rna_velo")
}

setwd("./17rna_velo")#切换工作目录

library(velocyto.R)
library(Seurat)
library(monocle)

#这里要monocle结果，可以load 前面保存的结果
#读入loom文件
ldat <- read.loom.matrices("/public/workspace/lincs/me/yao/17rna_velo/combined.loom")
save(ldat,file="ldat.RData")
#准备spliced数据和unspliced数据
emat <- ldat$spliced
nmat <- ldat$unspliced

#对细胞进行过滤进行过滤

#根据最小最大细胞类均值对基因进行过滤 min.max.cluster.average：不同细胞类型中，基因均值最大值大于该阈值，则该基因保留
cell_cluster <- as.character(pData(HSMM)$seurat_clusters)
names(cell_cluster) <- colnames(HSMM)
name1<-emat@Dimnames[[2]]
#mRNAmatrix<-data.frame(gene_id=name1)


#name2 <- mRNAmatrix %>% 
#  tidyr::separate(gene_id,into = c("gene_id","drop"),sep="\\:") %>% 
#  dplyr::select(drop)


#name2<-gsub("x","-1_2",name1)
#emat@Dimnames[[2]]<-name2

#name11<-gsub("cc2-150:","",nmat@Dimnames[[2]])
#name22<-gsub("x","-1_2",name11)
#nmat@Dimnames[[2]]<-name22
b<-colnames(HSMM)
emat<-emat[,(name1 %in% b)]
nmat<-nmat[,(name1 %in% b)]
	
emat <- filter.genes.by.cluster.expression(emat, cell_cluster, min.max.cluster.average = .1)
nmat <- filter.genes.by.cluster.expression(nmat, cell_cluster, min.max.cluster.average = .1)
length(intersect(rownames(emat), rownames(nmat)))

#RNA Velocity分析

### 参数设置
fit.quantile = 0.05 # 官方教程设定为 0.05
deltaT = 1 # default: 1
kCells = 10 # default: 10
### RNA velocity分析
rvel.qf <- gene.relative.velocity.estimates(emat, nmat, deltaT = deltaT, kCells = kCells, fit.quantile = fit.quantile)

colors <- c("#F8766D", "#C49A00", "#53B400", "#00C094", "#00B6EB", "#A58AFF", "#FB61D7")
names(colors) <- 0:6
### 参数设定
emb = t(reducedDimS(HSMM)) # DDRTree坐标
vel = rvel.qf # velocity estimates (步骤3的结果)
n = 100 # 最邻近细胞的数量
scale = "sqrt" # scale方法
# 散点的颜色（用以区分不同的细胞状态）
cell.colors = plyr::mapvalues(cell_cluster, names(colors), colors)
cell.alpha = 0.2 # 散点颜色的透明度
cell.cex = 1 # 散点的尺寸
arrow.scale = 1 # 箭头的长度
arrow.lwd = 1.5 # 箭头的粗细
grid.n = 50 # grids的数量

### plot
pdf(file="01tumor_RNA_velocity.pdf")
show.velocity.on.embedding.cor(emb, vel, n, scale=scale, 
                               cell.colors = ac(cell.colors, alpha = cell.alpha),
                               cex = cell.cex, arrow.scale = arrow.scale, 
                               show.grid.flow = TRUE, min.grid.cell.mass = 1,
                               grid.n = grid.n, arrow.lwd = arrow.lwd)
dev.off()


############################################################下面为scVelo步骤，不知能否成功
#####


###################################################第一部分： 数据下载比对，cellranger .9服务器


###################################################第二部分： RNA 速率linux
##cd /public/workspace/lincs/lab7/singlecell/velocyto/
##singularity shell velocyto_latest.sif
##velocyto  每1000个单独做


####################################################第三部分:R语言分析（注释细胞）
#############################R部分一：先读取比对结果文件，Seurat分析，见前面



########################R部分二：从seurat对象中提取meta-data
#（R语言运行）已经在R中使用Seurat执行了主要的数据处理（过滤、归一化、聚类、批次处理、降维，细胞类型注释），接下来，提取meta-data的主要信息：

#Filtered Cell Ids
#UMAP or TSNE coordinates
#Clusters/Celltype (Optional)
#Clusters/Celltype Colors (Optional)
singularity shell /public/workspace/lincs/lab7/soft/scRNA_20220525.sif
R
library(Seurat)
library(velocyto.R)
library(SeuratWrappers)
library(ggplot2)
library(scales)
#load("scRNA_harmony_3T_tumorcell.RData")
seurat_obj<-scRNA<-scRNA_harmony_Stromal_regroup2
Idents(scRNA)<-scRNA@meta.data$RNA_snn_res.0.3
seurat_obj$celltype <- seurat_obj$singleRnew
seurat_obj$cluster <- seurat_obj@meta.data$RNA_snn_res.0.3
#makedirs <- function(dir_list){ 
#  for (i_dir in dir_list){ 
#    if (!dir.exists(i_dir) ){ 
#      dir.create(i_dir, recursive = TRUE) 
#    } 
#  } 
#}
#--------------------------------------------------
#makedirs(file.path(project_work_dir, "rna_velocity")) 
#setwd(file.path(project_work_dir, "rna_velocity"))
table(seurat_obj$celltype)

library(stringi)
library(stringr)

#colnames(seurat_obj)<-str_replace(colnames(seurat_obj),"^X","")
# 获得每个细胞的UMAP或TSNE坐标，使用 Embeddings函数
write.csv(Embeddings(seurat_obj, reduction = "umap"), file = "cell_embeddings.csv")
# 获取每个细胞的barcode
write.csv(Cells(seurat_obj), file = "cellID_obs.csv", row.names = FALSE)
# 提取每个细胞的cluster信息
write.csv(seurat_obj@meta.data[, 'cluster', drop = FALSE], file = "cell_clusters.csv")
# 提取每个细胞的celltype信息
write.csv(seurat_obj@meta.data[, 'celltype', drop = FALSE], file = "cell_celltype.csv")
# 获取celltype的颜色信息
hue_pal()(length(levels(seurat_obj$celltype)))
# 获取cluster的颜色信息
hue_pal()(length(levels(seurat_obj$cluster)))

# 绘制umap图，与RNA速率图对比看
Idents(seurat_obj) <- "cluster"
alpha.use <- 0.8
p1 <- DimPlot(object = seurat_obj, reduction = "umap", label = TRUE, label.size = 5, pt.size=0.4, raster=FALSE)
p1$layers[[1]]$mapping$alpha <- alpha.use
ggsave("UMAP_clustering.png", p1,  dpi=600)
ggsave("UMAP_clustering.pdf", p1, )




##################################################第四部分：整合Loom文件和meta-data
#（python运行）整合loom文件和meta-data数据
#代码中有对loom文件barcode的处理，与seurat的barcode一致。
cd /public/workspace/lincs/lab7/singlecell/scVelo/
singularity shell scvelo_python_20220525.sif
cd /public/workspace/lincs/me/yao/17rna_velo/
python


# 整合多个loom文件,这个在前面弄好，导致重新分析，以后吃一堑长一智，先跑一下rna velocity,看一下细胞barcode，将barcode写入seurat分析的barcode中
import loompy
##本例中不需要整合
files=['./health1.loom','./health2.loom','severe.loom','SRR14118395_1_final_BJOLA.loom','SRR14118396_1_final_VM5EJ.loom','SRR14118397_1_final_UMN7O.loom','SRR14118398_1_final_0BF8R.loom','SRR14118400_1_final_HLIL8.loom','SRR14118401_1_final_O76E9.loom','SRR14118402_1_final_UHEXL.loom','SRR14118403_1_final_U5RLA.loom','SRR14118404_1_final_6P7TV.loom','SRR14118405_1_final_UHL6P.loom']
output_filename='combined.loom'
loompy.combine(files, output_filename, key="Accession")

# 整合loom文件和meta-data数据
import scvelo as scv
import pandas as pd
import numpy as np
import os

loom_data = scv.read('./combined.loom', cache=True,sparse=True)
#loom_data.obs

# barcode名字去重后缀x，与seurat导出的barcode名称一致
#loom_data.obs = loom_data.obs.rename(index = lambda x: x.replace('cc3:', '').replace('x', '-1_2'))
#loom_data.obs = loom_data.obs.rename(index = lambda x: x.replace('cc2-150:', '').replace('x', '-1_2'))

#barcodes = [bc.split(':')[1] for bc in loom_data.obs.index.tolist()]
#barcodes = [bc.split('.bam')[0] for bc in barcodes]
#loom_data.obs.index = barcodes 
loom_data.obs.head()

# 读取seurat中的meta信息
meta_path = "/public/workspace/lincs/me/yao/17rna_velo/"
sample_obs = pd.read_csv(os.path.join(meta_path, "cellID_obs.csv"))
cell_umap= pd.read_csv(os.path.join(meta_path, "cell_embeddings.csv"), header=0, names=["Cell ID", "UMAP_1", "UMAP_2"])
cell_clusters = pd.read_csv(os.path.join(meta_path, "cell_clusters.csv"), header=0, names=["Cell ID", "cluster"])
cell_celltype = pd.read_csv(os.path.join(meta_path, "cell_celltype.csv"), header=0, names=["Cell ID", "celltype"])

# 对细胞文件和RNA剪切速率文件取交集，保留关注的细胞类型
sample_one = loom_data[np.isin(loom_data.obs.index, sample_obs)]
sample_one.obs.head()
# 构建umap坐标, cluster, celltype信息数据框
sample_one_index = pd.DataFrame(sample_one.obs.index)

#####下面这句代码有问题，加入的一列列名竟然是CellID，我在下面这句代码后改成下一句才将列名改过来
#sample_one_index = sample_one_index.rename(columns = {0:'Cell ID'})
sample_one_index = sample_one_index.rename(columns = {'CellID':'Cell ID'})

umap_ordered = sample_one_index.merge(cell_umap, on = "Cell ID")
umap_ordered.head()
celltype_ordered = sample_one_index.merge(cell_celltype, on = "Cell ID")
celltype_ordered.head()
clusters_ordered = sample_one_index.merge(cell_clusters, on = "Cell ID")
clusters_ordered.head()

# 将umap坐标与cluster信息加入sample_one
umap_ordered = umap_ordered.iloc[:,1:]
clusters_ordered = clusters_ordered.iloc[:,1:]
celltype_ordered = celltype_ordered.iloc[:,1:]
sample_one.obsm['X_umap'] = umap_ordered.values
sample_one.uns['clusters'] = clusters_ordered.values
sample_one.obs['celltype'] = celltype_ordered.values
#sample_one.obs['clusters'] = clusters_ordered.values
adata = sample_one
# some gene labels are duplicated (Ensembl IDs are still unique!!)
adata.var_names_make_unique()

# save model to file
adata.write('Allcelltype_dynamicModel.h5ad', compression = 'gzip')

# read h5ad file
adata= scv.read('Allcelltype_dynamicModel.h5ad')

################################第五部分：运行RNA速率
###（python运行）可视化绘图
# Running RNA Velocity，开始选的是stochastic随机模型
scv.pp.filter_and_normalize(adata,min_shared_counts=30, n_top_genes=2000)
scv.pp.moments(adata, n_pcs=30, n_neighbors=10)
scv.tl.velocity(adata, mode = "stochastic")
scv.tl.velocity_graph(adata)
#计算潜在时间
scv.tl.latent_time(adata)

scv.pl.velocity_embedding(adata, basis='X_umap', arrow_size=5)
ident_colours = ["#FF766D", "#A3A500", "#0000FF", "#10B0F6", "#476BF3","#276DF3","#30C0F9","#F0766D", "#AF9A00", "#E3B400", "#A0C094", "#B0B6EB", "#C58A7F", "#EB91D7"]
scv.pl.velocity_embedding_stream(adata, basis='X_umap',color = "celltype", palette = ident_colours)
scv.pl.velocity_embedding_stream(adata, basis='X_umap',color = "celltype", palette = ident_colours, size = 20,alpha =0.8)
scv.pl.velocity_embedding_stream(adata, basis='X_umap',color = "celltype", palette = ident_colours, size = 20,alpha =0.8, save="UMAP_stream_RNA_velo.png", figsize=(7,5), legend_fontsize = 6, show=False, title='')
scv.pl.velocity_embedding_stream(adata, basis='X_umap',color = "celltype", palette = ident_colours, size = 20,alpha =0.8, save="UMAP_stream_RNA_velo.pdf", figsize=(7,5), legend_fontsize = 6, show=False, title='')

ident_colours = ["#FF766D", "#A3A500", "#0000FF", "#10B0F6", "#476BF3","#276DF3","#30C0F9","#F0766D", "#AF9A00", "#E3B400", "#A0C094", "#B0B6EB", "#C58A7F", "#EB91D7"]
scv.pl.velocity_embedding_stream(adata, basis='X_umap',color = "clusters", palette = ident_colours)
scv.pl.velocity_embedding_stream(adata, basis='X_umap',color = "clusters", palette = ident_colours, size = 20,alpha =0.8)
scv.pl.velocity_embedding_stream(adata, basis='X_umap',color = "clusters", palette = ident_colours, size = 20,alpha =0.8, save="UMAP_stream_RNA_velo.png", figsize=(7,5), legend_fontsize = 6, show=False, title='')
scv.pl.velocity_embedding_stream(adata, basis='X_umap',color = "clusters", palette = ident_colours, size = 20,alpha =0.8, save="UMAP_stream_RNA_velo.pdf", figsize=(7,5), legend_fontsize = 6, show=False, title='')


#scv.pl.velocity_embedding_stream(adata,basis="X_umap",color="latent_time",title="latent_time",color_map="plasma",save='scVelo-umap-latent_time.pdf')

#latent time可视化

#    "#F8766D" "#E68613" "#CD9600" "#ABA300" "#7CAE00" "#0CB702" "#00BE67" "#00C19A" "#00BFC4" "#00B8E7" "#00A9FF" "#8494FF" "#C77CFF" "#ED68ED" "#FF61CC" "#FF68A1"

ident_colours = ["#F8766D", "#E68613", "#ABA300", "#0CB702", "#00C19A","#00BFC4","#00A9FF","#8494FF", "#C77CFF", "#ED68ED"]




###这是科研代码
#计算速率，使用动力学模型
scv.tl.recover_dynamics(adata)#动力学模型
scv.tl.velocity(adata, mode='dynamical')#计算速率
scv.tl.velocity_graph(adata)#计算速率图
#计算潜在时间
scv.tl.latent_time(adata)
scv.pl.velocity_embedding_stream(adata, basis='X_umap',color = "clusters", palette = ident_colours, size = 20,alpha =0.8, save="UMAP_stream_RNA_velo.pdf", figsize=(5,5), legend_fontsize = 6, show=False, title='')

scv.pl.velocity_embedding_stream(adata,basis="X_umap",color="latent_time",title="latent_time",color_map="plasma",save='scVelo-umap-latent_time.pdf')


#top 100个driver基因热图，diver基因即指代与细胞分化轨迹相关的基因
top_genes = adata.var['fit_likelihood'].sort_values(ascending=False).index[:100] #top100个基因
scv.pl.heatmap(adata, var_names=top_genes, sortby='latent_time', col_color='clusters',n_convolve=100,figsize=(16,20),yticklabels=True,sort=True,colorbar=True,show=True,layer='count',save='scVelo-heatmap-top100-latent_time.pdf')#热图

#top 15个diver基因散点图
top_genes = adata.var['fit_likelihood'].sort_values(ascending=False).index[:15]#top15个基因
scv.pl.scatter(adata, basis=top_genes, ncols=5, frameon=False,save='scVelo-scatter-top15-latent_time.pdf')

#横坐标为latent time的散点图，描述感兴趣的driver基因
scv.pl.scatter(adata, x='latent_time', y=top_genes, ncols=5,frameon=False,save='scVelo-scatter1-top15-latent_time2.pdf')

#细胞类型特异基因鉴定，
scv.tl.rank_dynamical_genes(adata, groupby='clusters')#对每个细胞类型的基因按照似然率大小进行排序
df = scv.get_df(adata, 'rank_dynamical_genes/names')#根据指定key，来获取数据框
df.head(5)#列出数据框前5行
df.to_csv('clusters_specific_genes.csv')#结果输出到文件
###下面2行有问题，运行不了
#细胞类型特异基因, top10可视化
for cluster in ['0','1', '2', '3', '4','5','6','7','8','9']:
    scv.pl.scatter(adata, df[cluster][:10], ylabel=cluster,ncols=5,frameon=False,save=cluster+'_top10_specific_genes.pdf')


#差异动力学检验，看是否构建的轨迹整体和局部是否统一
top_genes = adata.var['fit_likelihood'].sort_values(ascending=False).index[:100] #top 100 genes
scv.tl.differential_kinetic_test(adata, var_names=top_genes, groupby='clusters') #差异动力学检验
res=scv.get_df(adata[:, top_genes], ['fit_diff_kinetics', 'fit_pval_kinetics'])#得到数据框
res.to_csv("diff_kinetics_test.csv")#结果写到文件里

#top 15 genes 可视化，散点图
kwargs = dict(linewidth=2, add_linfit=True, frameon=False) #用字典dict函数来构建一个参数字典
scv.pl.scatter(adata, basis=top_genes[:15], ncols=5, add_outline='fit_diff_kinetics', **kwargs,save="diff_kinetics_scatter.pdf")
####下面不用运行
# 通过统计检验，发现整体和局部不是很统一，存在多个分化轨迹，这时重新计算速率，执行上面的分析步骤。
scv.tl.recover_dynamics(adata)#动力学模型
scv.tl.velocity(adata, mode='dynamical',diff_kinetics=True) #加入diff_kinetics=True参数即可，计算速率
scv.tl.velocity_graph(adata)#计算速率图
scv.tl.latent_time(adata)#计算潜在时间，即伪时间


############################################19slingshot
setwd("/public/workspace/lincs/lab7/oral/new20221004/")#切换工作目录
load("./16Neu_regroup/scRNA_harmony_Neutrophils_regroup.Rdata")
scRNA<-scRNA_harmony_Neutrophils_regroup
if (!dir.exists("19slingshot")){
dir.create("19slingshot")
}

setwd("./19slingshot")#切换工作目录
library(Seurat)


library(SingleCellExperiment)
library(slingshot, quietly = TRUE)
library(RColorBrewer)
library(Seurat)
library(ggplot2)
library(uwot)
library(mclust, quietly = TRUE)
library(grDevices)



pbmc<-scRNA
#start slingshot
set.seed(123456)

#########注意了，需要几个内容：counts,细胞cluster,tsne或者umap
counts<-pbmc@assays$RNA@counts
group.dat <- data.frame(cellType=pbmc$seurat_clusters) 
sce <- SingleCellExperiment(assays = List(counts = counts),colData = group.dat)

## ----tsne, cache=TRUE---------------------------------------------------------
rd2 <- pbmc@reductions$umap@cell.embeddings
colnames(rd2) <- c('UMAP1', 'UMAP2')

## ----add_RDs, cache=TRUE------------------------------------------------------
reducedDims(sce) <- SimpleList(UMAP = rd2)

## ----sling_sce----------------------------------------------------------------
sce <- slingshot(sce, clusterLabels = sce$cellType, reducedDim = 'UMAP')

## ----plot_curve_1-------------------------------------------------------------
cell_pal <- function(cell_vars,...) {
  if (is.numeric(cell_vars)) {
    pal <- brewer.pal(cell_vars,'Set3')
    return(pal[cut(cell_vars, breaks = 100)])
  } else {
    categories <- sort(unique(cell_vars))
    pal <- setNames(brewer.pal(length(categories),'Set3'), categories)
    return(pal[cell_vars])
  }
}
# 这里根据细胞类型设颜色,是一个产生颜色的函数
cell_colors <- cell_pal(sce$cellType)

pdf("plot_curve_1.UMAP.pdf")
colors <- colorRampPalette(brewer.pal(11,'Spectral')[-6])(100)
plotcol <- colors[cut(sce$slingPseudotime_1, breaks=100)]
plot(reducedDims(sce)$UMAP, col = plotcol, pch=16, asp = 1)
lines(SlingshotDataSet(sce), lwd=2, col='black')
dev.off()

pdf("plot_curve_2.UMAP.pdf")
par(mar=c(5.1, 4.1, 4.1, 14), xpd=TRUE)
plot(reducedDims(sce)$UMAP, col = cell_colors, pch=16, asp = 1)
lines(SlingshotDataSet(sce), lwd=2, type = 'lineages', col = 'black')
legend("right", inset = c(-0.6, 0), legend = unique(sce$cellType), 
       col = unique(cell_colors), pch = 16, box.lwd = 0)
dev.off()






###########################################################################################################18pySCENIC
####################################################################跑了
#####pySCENIC运行流程
library(Seurat)
library(SCENIC)
library(tidyverse)
library(patchwork)


load("20231227.RData")
scRNA<-scRNA_harmony

###### 准备pySCENIC输入矩阵
set.seed(123456)

mat <- as.matrix(scRNA@assays$RNA@data)
mat.filter <- mat[rowSums(mat)>ncol(mat)*0.01,]
write.csv(t(mat.filter), file='18pySCENIC/expr_pyscenic.csv')

#################巨噬细胞也来一遍
scRNA<-scRNA_harmony_Macrophage_regroup
mat <- as.matrix(scRNA@assays$RNA@data)
mat.filter <- mat[rowSums(mat)>ncol(mat)*0.01,]
write.csv(t(mat.filter), file='19pySCENIC-macro/expr_pyscenic.csv')






#数据用/home/dell/singlecell/CC/scenic/文件夹下 expr_pyscenic.csv
#软件用 /home/dell/scRNA2/singlecell/scenic/文件夹下aertslab-pyscenic-0.10.0.sif
#你们把需要的文件拷贝过去，人的参考文件
##给出的代码没有设置种子，你们运行时需要设置种子 --seed SEED 123456 
#以下是我在.9服务器上成功运行的代码，供你们参考。
cd /home/server/data1/lab7/singlecell/scenic/
singularity shell aertslab-pyscenic-0.10.0.sif
cd /home/server/data1/jyz/Ctrl_EcO/18pySCENIC/

###############################
cd /home/server/data1/lab7/singlecell/scenic/
singularity shell aertslab-pyscenic-0.10.0.sif
cd /home/server/data1/jyz/Ctrl_EcO/19pySCENIC-macro/

## 计算调控权重
pyscenic grn --num_workers 39 -o ./Links.csv ./expr_pyscenic.csv /home/server/data1/lab7/singlecell/scenic/cisTarget_databases/hs_hgnc_tfs.txt --seed 123456
## 生成调控单元
pyscenic ctx \
        ./Links.csv \
        /home/server/data1/lab7/singlecell/scenic/cisTarget_databases/hg38__refseq-r80__500bp_up_and_100bp_down_tss.mc9nr.feather \
        /home/server/data1/lab7/singlecell/scenic/cisTarget_databases/hg38__refseq-r80__10kb_up_and_down_tss.mc9nr.feather \
        --annotations_fname /home/server/data1/lab7/singlecell/scenic/cisTarget_databases/motifs-v9-nr.hgnc-m0.001-o0.0.tbl \
        --expression_mtx_fname ./expr_pyscenic.csv \
        --mode "dask_multiprocessing" \
        --output ./regulons.csv \
        --num_workers 30
## 计算活性分数
pyscenic aucell \
        ./expr_pyscenic.csv \
        ./regulons.csv \
        -o ./auc_mtx.csv \
        --num_workers 30

##########
###### R环境开展下游分析
library(SCENIC)
library(AUCell)
library(tidyverse)
library(patchwork)
rm(list = ls())
set.seed(123456)
setwd("/public/workspace/lincs/me/yao/18pySCENIC/")

## 提取regulons基因集
#定义一些函数
Regulons2Genesets <- function(regulons_fn){
regulons <- read.csv(regulons_fn)
row1 <- regulons[1,3:ncol(regulons)]
row2 <- regulons[2,1:2]
colnames(regulons) <- c(row2, row1)
regulons <- regulons[-c(1:2),]
list.tmp <- split(regulons$TargetGenes, regulons$TF)
genesets <- lapply(list.tmp, function(x) {
  tmp1 <- paste(x, collapse = ",") %>% gsub('\\[|\\]|\\(|\\)|', '', .) %>% gsub(" ","",.)
  tmp2 <- gsub("'", "", tmp1) %>% gsub(",[0-9]+\\.[0-9]+", "", .)
  tmp3 <- strsplit(tmp2, split = ",")[[1]] %>% unique()
  return(tmp3) })
return(genesets)
}

rssplot <- function(rss, topN=5){
require(ggplot2)
require(ggrepel)
plot <- list()
for(i in colnames(rss)){
  df.i <- data.frame(SpecificityScore=rss[,i], labels=rownames(rss))
  df.i <- arrange(df.i, desc(SpecificityScore)) %>% as.data.frame()
  df.i$Regulons <- 1:nrow(df.i)
  df.i$color <- ifelse(df.i$Regulons <= topN, "red", "gray")
  df.i$labels[df.i$Regulons > topN] <- NA
  p <- ggplot(df.i, aes(Regulons, SpecificityScore)) +
    geom_point(size=3, color = df.i$color) + 
    geom_text_repel(aes(label=labels), size=4) + 
    scale_x_continuous(limits = c(0, 200)) +
    ggtitle(i) + xlab("Regulons Rank") + ylab("Specificity Score") + 
    theme_bw(base_size = 12) + 
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          plot.title = element_text(hjust = 0.5))
  plot[[i]] <- p
}
return(plot)
}

avgRasHeatmap <- function(regulonAUC, cellInfo, group.by, topN=50, cluster_rows=TRUE, 
                        color = colorRampPalette(c("#64C9CF", "white", "#FF4848"))(50),
                        border_color=NA, cluster_cols=TRUE, fontsize=10, scale="row"){
require(pheatmap)
require(reshape2)
avgRegAUC <- sapply(split(rownames(cellInfo), as.character(cellInfo[[group.by]])), 
                    function(cells) rowMeans(regulonAUC[,cells]))
topRegs <- reshape2::melt(avgRegAUC)
colnames(topRegs) <- c("Regulon", "CellType", "avg.RAS")
topRegs <- group_by(topRegs, CellType) %>% top_n(n=topN, wt=avg.RAS) %>% pull(Regulon)
topRegs <- as.character(topRegs) %>% unique()
p <- pheatmap(avgRegAUC[topRegs,], cluster_rows=cluster_rows, color=color, scale=scale,
              border_color = border_color, cluster_cols = cluster_cols, fontsize = fontsize)
return(p)
}

reg.genesets <- Regulons2Genesets("regulons.csv")
save(reg.genesets, file = "reg.genesets.rda")

## AUC矩阵二进制转化
regulonAUC <- read.csv("auc_mtx.csv", row.names = 1, check.names = F)
regulonAUC <- t(regulonAUC)
rownames(regulonAUC) <- gsub("(+)", "", rownames(regulonAUC), fixed = T)
saveRDS(regulonAUC, file = "regulonAUC.rds")

# 运行时间比较长
bin.T <- AUCell_exploreThresholds(regulonAUC,
                                  smallestPopPercent=0.25,
                                  assignCells=TRUE, 
                                  plotHist=FALSE,
                                  verbose=FALSE)
saveRDS(bin.T, "binThresholds.rds")

regulonBin <- lapply(rownames(regulonAUC), function(reg){
  as.numeric(colnames(regulonAUC) %in% bin.T[[reg]][["assignment"]])
})
regulonBin <- do.call("rbind", regulonBin)
dimnames(regulonBin) <- list(rownames(regulonAUC), colnames(regulonAUC))
saveRDS(regulonBin, "regulonBin.rds")

## 计算RSS矩阵(Regulon Specificity Score)
#load("/public/workspace/lincs/me/yao/01RDada/02_scRNA_harmony_singler.Rdata")
sco <- scRNA_harmony_singler
regulonAUC <- read.csv("auc_mtx.csv", row.names = 1, check.names = F)
regulonAUC <- t(regulonAUC)
rownames(regulonAUC) <- gsub("(+)", "", rownames(regulonAUC), fixed = T)
rss <- calcRSS(regulonAUC, sco$singleRnew)
rss.plot <- rssplot(rss = rss)

p <- wrap_plots(rss.plot, ncol = 2)
ggsave("01RSS.pdf", p, width = 9, height = 80, limitsize = F)

## 分组与regulon相关性热图
p = avgRasHeatmap(regulonAUC = regulonAUC, cellInfo = sco@meta.data, group.by = "group")
ggsave("02avgRasHeatmap.pdf", p, width = 9, height = 9)

## regulons降维聚类
library(Seurat)
sco[["Regulon"]] <- CreateAssayObject(counts = regulonAUC)
sco[["binRegulon"]] <- CreateAssayObject(counts = regulonBin)
DefaultAssay(sco) <- "Regulon"
sco.x <- NormalizeData(sco) %>% ScaleData(features = rownames(sco))
sco.x <- RunPCA(sco.x, features = rownames(sco))
sco.x <- FindNeighbors(sco.x, dims = 1:50) %>% FindClusters()
sco.x <- RunUMAP(sco.x, dims = 1:50)
saveRDS(sco.x, "sco.x.rds")

DefaultAssay(sco) <- "RNA"
p1 <- DimPlot(sco, reduction = "umap", group.by = "singleRnew", label = T) + NoLegend() + ggtitle("gene expression")
p2 <- DimPlot(sco.x, group.by = "singleRnew", label = T) + NoLegend() + ggtitle("regulon activation")
p <- p1|p2
ggsave("03umap_group.pdf", p, width = 15, height = 7)

library(ggpubr)
rn  = "CHD1"
tf <- rn
p1 <- DimPlot(sco, reduction = "umap", group.by = "group", label = T) + NoLegend()
DefaultAssay(sco) <- "binRegulon"
p2 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("CHD1_binRAS")
DefaultAssay(sco) <- "Regulon"
p3 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("CHD1_RAS")
DefaultAssay(sco) <- "RNA"
p4 <- FeaturePlot(sco, reduction = "umap", features = tf) + ggtitle("CHD1_geneExpr")
df1 <- data.frame(cluster=sco$group, auc=sco@assays$Regulon@counts[rn,], row.names = colnames(sco))
p5 <- ggboxplot(df1, x='cluster', y='auc', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("CHD1_RAS") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
df2 <- data.frame(cluster=sco$group, expr=sco@assays$RNA@data[tf,], row.names = colnames(sco))
p6 <- ggboxplot(df2, x='cluster', y='expr', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("CHD1_geneExpr") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
p <- (p1|p3|p4)/(p2|p5|p6)
ggsave("04-CHD1_overview.pdf", p, width = 16, height = 9)  


library(ggpubr)
rn  = "NFIL3"
tf <- rn
p1 <- DimPlot(sco, reduction = "umap", group.by = "group", label = T) + NoLegend()
DefaultAssay(sco) <- "binRegulon"
p2 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("NFIL3_binRAS")
DefaultAssay(sco) <- "Regulon"
p3 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("NFIL3_RAS")
DefaultAssay(sco) <- "RNA"
p4 <- FeaturePlot(sco, reduction = "umap", features = tf) + ggtitle("NFIL3_geneExpr")
df1 <- data.frame(cluster=sco$group, auc=sco@assays$Regulon@counts[rn,], row.names = colnames(sco))
p5 <- ggboxplot(df1, x='cluster', y='auc', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("NFIL3_RAS") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
df2 <- data.frame(cluster=sco$group, expr=sco@assays$RNA@data[tf,], row.names = colnames(sco))
p6 <- ggboxplot(df2, x='cluster', y='expr', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("NFIL3_geneExpr") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
p <- (p1|p3|p4)/(p2|p5|p6)
ggsave("04-NFIL3_overview.pdf", p, width = 16, height = 9)  


library(ggpubr)
rn  = "BCL6"
tf <- rn
p1 <- DimPlot(sco, reduction = "umap", group.by = "group", label = T) + NoLegend()
DefaultAssay(sco) <- "binRegulon"
p2 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("BCL6_binRAS")
DefaultAssay(sco) <- "Regulon"
p3 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("BCL6_RAS")
DefaultAssay(sco) <- "RNA"
p4 <- FeaturePlot(sco, reduction = "umap", features = tf) + ggtitle("BCL6_geneExpr")
df1 <- data.frame(cluster=sco$group, auc=sco@assays$Regulon@counts[rn,], row.names = colnames(sco))
p5 <- ggboxplot(df1, x='cluster', y='auc', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("BCL6_RAS") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
df2 <- data.frame(cluster=sco$group, expr=sco@assays$RNA@data[tf,], row.names = colnames(sco))
p6 <- ggboxplot(df2, x='cluster', y='expr', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("BCL6_geneExpr") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
p <- (p1|p3|p4)/(p2|p5|p6)
ggsave("04-BCL6_overview.pdf", p, width = 16, height = 9)  


library(ggpubr)
rn  = "EGR3"
tf <- rn
p1 <- DimPlot(sco, reduction = "umap", group.by = "group", label = T) + NoLegend()
DefaultAssay(sco) <- "binRegulon"
p2 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("EGR3_binRAS")
DefaultAssay(sco) <- "Regulon"
p3 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("EGR3_RAS")
DefaultAssay(sco) <- "RNA"
p4 <- FeaturePlot(sco, reduction = "umap", features = tf) + ggtitle("EGR3_geneExpr")
df1 <- data.frame(cluster=sco$group, auc=sco@assays$Regulon@counts[rn,], row.names = colnames(sco))
p5 <- ggboxplot(df1, x='cluster', y='auc', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("EGR3_RAS") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
df2 <- data.frame(cluster=sco$group, expr=sco@assays$RNA@data[tf,], row.names = colnames(sco))
p6 <- ggboxplot(df2, x='cluster', y='expr', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("EGR3_geneExpr") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
p <- (p1|p3|p4)/(p2|p5|p6)
ggsave("04-EGR3_overview.pdf", p, width = 16, height = 9)  


library(ggpubr)
rn  = "EGR3"
tf <- rn
p1 <- DimPlot(sco, reduction = "umap", group.by = "group", label = T) + NoLegend()
DefaultAssay(sco) <- "binRegulon"
p2 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("EGR3_binRAS")
DefaultAssay(sco) <- "Regulon"
p3 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("EGR3_RAS")
DefaultAssay(sco) <- "RNA"
p4 <- FeaturePlot(sco, reduction = "umap", features = tf) + ggtitle("EGR3_geneExpr")
df1 <- data.frame(cluster=sco$group, auc=sco@assays$Regulon@counts[rn,], row.names = colnames(sco))
p5 <- ggboxplot(df1, x='cluster', y='auc', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("EGR3_RAS") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
df2 <- data.frame(cluster=sco$group, expr=sco@assays$RNA@data[tf,], row.names = colnames(sco))
p6 <- ggboxplot(df2, x='cluster', y='expr', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("EGR3_geneExpr") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
p <- (p1|p3|p4)/(p2|p5|p6)
ggsave("04-EGR3_overview.pdf", p, width = 16, height = 9)  

library(ggpubr)
rn  = "EGR1"
tf <- rn
p1 <- DimPlot(sco, reduction = "umap", group.by = "group", label = T) + NoLegend()
DefaultAssay(sco) <- "binRegulon"
p2 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("EGR1_binRAS")
DefaultAssay(sco) <- "Regulon"
p3 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("EGR1_RAS")
DefaultAssay(sco) <- "RNA"
p4 <- FeaturePlot(sco, reduction = "umap", features = tf) + ggtitle("EGR1_geneExpr")
df1 <- data.frame(cluster=sco$group, auc=sco@assays$Regulon@counts[rn,], row.names = colnames(sco))
p5 <- ggboxplot(df1, x='cluster', y='auc', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("EGR1_RAS") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
df2 <- data.frame(cluster=sco$group, expr=sco@assays$RNA@data[tf,], row.names = colnames(sco))
p6 <- ggboxplot(df2, x='cluster', y='expr', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("EGR1_geneExpr") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
p <- (p1|p3|p4)/(p2|p5|p6)
ggsave("04-EGR1_overview.pdf", p, width = 16, height = 9)  

library(ggpubr)
rn  = "DDIT3"
tf <- rn
p1 <- DimPlot(sco, reduction = "umap", group.by = "group", label = T) + NoLegend()
DefaultAssay(sco) <- "binRegulon"
p2 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("DDIT3_binRAS")
DefaultAssay(sco) <- "Regulon"
p3 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("DDIT3_RAS")
DefaultAssay(sco) <- "RNA"
p4 <- FeaturePlot(sco, reduction = "umap", features = tf) + ggtitle("DDIT3_geneExpr")
df1 <- data.frame(cluster=sco$group, auc=sco@assays$Regulon@counts[rn,], row.names = colnames(sco))
p5 <- ggboxplot(df1, x='cluster', y='auc', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("DDIT3_RAS") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
df2 <- data.frame(cluster=sco$group, expr=sco@assays$RNA@data[tf,], row.names = colnames(sco))
p6 <- ggboxplot(df2, x='cluster', y='expr', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("DDIT3_geneExpr") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
p <- (p1|p3|p4)/(p2|p5|p6)
ggsave("04-DDIT3_overview.pdf", p, width = 16, height = 9)  


library(ggpubr)
rn  = "ELF2"
tf <- rn
p1 <- DimPlot(sco, reduction = "umap", split.by = "group", label = T) + NoLegend()
DefaultAssay(sco) <- "binRegulon"
p2 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("ELF2_binRAS")
DefaultAssay(sco) <- "Regulon"
p3 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("ELF2_RAS")
DefaultAssay(sco) <- "RNA"
p4 <- FeaturePlot(sco, reduction = "umap", features = tf) + ggtitle("ELF2_geneExpr")
df1 <- data.frame(cluster=sco$group, auc=sco@assays$Regulon@counts[rn,], row.names = colnames(sco))
p5 <- ggboxplot(df1, x='cluster', y='auc', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("ELF2_RAS") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
df2 <- data.frame(cluster=sco$group, expr=sco@assays$RNA@data[tf,], row.names = colnames(sco))
p6 <- ggboxplot(df2, x='cluster', y='expr', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("ELF2_geneExpr") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
p <- (p1|p3|p4)/(p2|p5|p6)
ggsave("05-ELF2_overview.pdf", p, width = 16, height = 9)  


library(ggpubr)
rn  = "NFKB2"
tf <- rn
p1 <- DimPlot(sco, reduction = "umap", group.by = "group", label = T) + NoLegend()
DefaultAssay(sco) <- "binRegulon"
p2 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("NFKB2_binRAS")
DefaultAssay(sco) <- "Regulon"
p3 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("NFKB2_RAS")
DefaultAssay(sco) <- "RNA"
p4 <- FeaturePlot(sco, reduction = "umap", features = tf) + ggtitle("NFKB2_geneExpr")
df1 <- data.frame(cluster=sco$group, auc=sco@assays$Regulon@counts[rn,], row.names = colnames(sco))
p5 <- ggboxplot(df1, x='cluster', y='auc', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("NFKB2_RAS") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
df2 <- data.frame(cluster=sco$group, expr=sco@assays$RNA@data[tf,], row.names = colnames(sco))
p6 <- ggboxplot(df2, x='cluster', y='expr', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("NFKB2_geneExpr") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
p <- (p1|p3|p4)/(p2|p5|p6)
ggsave("05-NFKB2_overview.pdf", p, width = 16, height = 9)  


library(ggpubr)
rn  = "FOSL2"
tf <- rn
p1 <- DimPlot(sco, reduction = "umap", group.by = "group", label = T) + NoLegend()
DefaultAssay(sco) <- "binRegulon"
p2 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("FOSL2_binRAS")
DefaultAssay(sco) <- "Regulon"
p3 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("FOSL2_RAS")
DefaultAssay(sco) <- "RNA"
p4 <- FeaturePlot(sco, reduction = "umap", features = tf) + ggtitle("FOSL2_geneExpr")
df1 <- data.frame(cluster=sco$group, auc=sco@assays$Regulon@counts[rn,], row.names = colnames(sco))
p5 <- ggboxplot(df1, x='cluster', y='auc', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("FOSL2_RAS") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
df2 <- data.frame(cluster=sco$group, expr=sco@assays$RNA@data[tf,], row.names = colnames(sco))
p6 <- ggboxplot(df2, x='cluster', y='expr', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("FOSL2_geneExpr") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
p <- (p1|p3|p4)/(p2|p5|p6)
ggsave("05-FOSL2_overview.pdf", p, width = 16, height = 9)  


library(ggpubr)
rn  = "CREM"
tf <- rn
p1 <- DimPlot(sco, reduction = "umap", group.by = "group", label = T) + NoLegend()
DefaultAssay(sco) <- "binRegulon"
p2 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("CREM_binRAS")
DefaultAssay(sco) <- "Regulon"
p3 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("CREM_RAS")
DefaultAssay(sco) <- "RNA"
p4 <- FeaturePlot(sco, reduction = "umap", features = tf) + ggtitle("CREM_geneExpr")
df1 <- data.frame(cluster=sco$group, auc=sco@assays$Regulon@counts[rn,], row.names = colnames(sco))
p5 <- ggboxplot(df1, x='cluster', y='auc', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("CREM_RAS") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
df2 <- data.frame(cluster=sco$group, expr=sco@assays$RNA@data[tf,], row.names = colnames(sco))
p6 <- ggboxplot(df2, x='cluster', y='expr', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("CREM_geneExpr") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
p <- (p1|p3|p4)/(p2|p5|p6)
ggsave("05-CREM_overview.pdf", p, width = 16, height = 9)  

#########################################
library(ggpubr)
rn  = "NFE2L2"
tf <- rn
p1 <- DimPlot(sco, reduction = "umap", group.by = "group", label = T) + NoLegend()
DefaultAssay(sco) <- "binRegulon"
p2 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("NFE2L2_binRAS")
DefaultAssay(sco) <- "Regulon"
p3 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("NFE2L2_RAS")
DefaultAssay(sco) <- "RNA"
p4 <- FeaturePlot(sco, reduction = "umap", features = tf) + ggtitle("NFE2L2_geneExpr")
df1 <- data.frame(cluster=sco$group, auc=sco@assays$Regulon@counts[rn,], row.names = colnames(sco))
p5 <- ggboxplot(df1, x='cluster', y='auc', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("NFE2L2_RAS") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
df2 <- data.frame(cluster=sco$group, expr=sco@assays$RNA@data[tf,], row.names = colnames(sco))
p6 <- ggboxplot(df2, x='cluster', y='expr', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("NFE2L2_geneExpr") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
p <- (p1|p3|p4)/(p2|p5|p6)
ggsave("05-NFE2L2_overview.pdf", p, width = 16, height = 9)  




library(ggpubr)
rn  = "RARA"
tf <- rn
p1 <- DimPlot(sco, reduction = "umap", group.by = "group", label = T) + NoLegend()
DefaultAssay(sco) <- "binRegulon"
p2 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("RARA_binRAS")
DefaultAssay(sco) <- "Regulon"
p3 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("RARA_RAS")
DefaultAssay(sco) <- "RNA"
p4 <- FeaturePlot(sco, reduction = "umap", features = tf) + ggtitle("RARA_geneExpr")
df1 <- data.frame(cluster=sco$group, auc=sco@assays$Regulon@counts[rn,], row.names = colnames(sco))
p5 <- ggboxplot(df1, x='cluster', y='auc', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("RARA_RAS") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
df2 <- data.frame(cluster=sco$group, expr=sco@assays$RNA@data[tf,], row.names = colnames(sco))
p6 <- ggboxplot(df2, x='cluster', y='expr', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("RARA_geneExpr") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
p <- (p1|p3|p4)/(p2|p5|p6)
ggsave("04-RARA_overview.pdf", p, width = 16, height = 9)  


library(ggpubr)
rn  = "RARA"
tf <- rn
p1 <- DimPlot(sco, reduction = "umap", group.by = "group", label = T) + NoLegend()
DefaultAssay(sco) <- "binRegulon"
p2 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("RARA_binRAS")
DefaultAssay(sco) <- "Regulon"
p3 <- FeaturePlot(sco, reduction = "umap", features = rn) + ggtitle("RARA_RAS")
DefaultAssay(sco) <- "RNA"
p4 <- FeaturePlot(sco, reduction = "umap", features = tf) + ggtitle("RARA_geneExpr")
df1 <- data.frame(cluster=sco$group, auc=sco@assays$Regulon@counts[rn,], row.names = colnames(sco))
p5 <- ggboxplot(df1, x='cluster', y='auc', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("RARA_RAS") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
df2 <- data.frame(cluster=sco$group, expr=sco@assays$RNA@data[tf,], row.names = colnames(sco))
p6 <- ggboxplot(df2, x='cluster', y='expr', fill='cluster', bxp.errorbar = T, outlier.shape = NA) +
  ggtitle("RARA_geneExpr") + NoLegend() + theme(plot.title = element_text(hjust = 0.5)) + RotatedAxis() 
p <- (p1|p3|p4)/(p2|p5|p6)
ggsave("04-RARA_overview.pdf", p, width = 16, height = 9)  



sco <- scRNA_harmony
regulonAUC <- read.csv("auc_mtx.csv", row.names = 1, check.names = F)
regulonAUC <- t(regulonAUC)
rownames(regulonAUC) <- gsub("(+)", "", rownames(regulonAUC), fixed = T)
rss <- calcRSS(regulonAUC, sco$newgroup)
rss.plot <- rssplot(rss = rss)

p <- wrap_plots(rss.plot, ncol = 2)
ggsave("RSS_newgroup.pdf", p, width = 9, height = 24, limitsize = F)

## celltype与regulon相关性热图
p = avgRasHeatmap(regulonAUC = regulonAUC, cellInfo = sco@meta.data, group.by = "group")
ggsave("avgRasHeatmap_newgroup.pdf", p, width = 9, height = 9)

#####################################################################20pySCENIC
#128服务器
conda activate clusterProfiler
cd /home/server/data1/jyz/Ctrl_EcO/
R
load("/home/server/data1/jyz/Ctrl_EcO/01RDada/06_scRNA_harmony_singler20240621.Rdata")
## (2) cell matrix (for step1): *.csv or *.loom

mat <- as.matrix(scRNA_harmony_singler2@assays$RNA@data)
mat.filter <- mat[rowSums(mat)>ncol(mat)*0.01,]

mc.mat <- mat.filter
## (2.1) 过滤低表达基因
#expr.in.cells <- rowSums(mc.mat > 0)
#mc.mat <- mc.mat[expr.in.cells >= 5, ]
## (2.2) 过滤不在cisTargetDB中的基因
cisdb <- arrow::read_feather("/home/server/data1/gzsx/scRNA/grn-new/cisTarget_db/hg38_10kbp_up_10kbp_down_full_tx_v10_clust.genes_vs_motifs.rankings.feather")
genes.use <- intersect(colnames(cisdb), rownames(mc.mat))
length(genes.use)
dim(mc.mat)
mc.mat <- mc.mat[genes.use, ]
dim(mc.mat)

## 保存为loom文件
loom <- SCopeLoomR::build_loom(
  file.name         = "00-2.mc_mat_for_step1.loom",
  dgem              = mc.mat,
  default.embedding = NULL
)
loom$close()

## 释放loom对象，允许其它文件占用loom文件
rm(loom)
gc()
#############################
## inputs
singularity shell /home/server/data1/gzsx/scRNA/grn-new/aertslab-pyscenic-0.12.1.sif
cd /home/server/data1/jyz/Ctrl_EcO/20pySCENIC/
f_loom_grn=00-2.mc_mat_for_step1.loom
## outputs
grn_output=01-step1_adj.tsv
ctx_output=01-step2_reg.tsv


## reference

f_tfs=/home/server/data1/gzsx/scRNA/grn-new/cisTarget_db/hsa_hgnc_tfs.motifs-v10.txt
f_motif_path=/home/server/data1/gzsx/scRNA/grn-new/cisTarget_db/motifs-v10nr_clust-nr.hgnc-m0.001-o0.0.tbl
f_db_500bp=/home/server/data1/gzsx/scRNA/grn-new/cisTarget_db/hg38_500bp_up_100bp_down_full_tx_v10_clust.genes_vs_motifs.rankings.feather
f_db_10kb=/home/server/data1/gzsx/scRNA/grn-new/cisTarget_db/hg38_10kbp_up_10kbp_down_full_tx_v10_clust.genes_vs_motifs.rankings.feather


#### 1. build GRN
## 
#aertslab-pyscenic-0.12.1.sif 

pyscenic grn \
--seed 777 \
--num_workers 70 \
--method grnboost2 \
-o ./$grn_output \
$f_loom_grn \
$f_tfs

#### 2. cisTarget
## ~30 mins 内存占用小

#../aertslab-pyscenic-0.12.1.sif \

pyscenic ctx \
./$grn_output \
$f_db_500bp $f_db_10kb \
--annotations_fname $f_motif_path \
--expression_mtx_fname $f_loom_grn \
--output $ctx_output \
--num_workers 70

#### 3. regulon => *.gmt

#../aertslab-pyscenic-0.12.1.sif \

python /home/server/data1/gzsx/scRNA/grn-new/scripts/02_regulon2gmt_new.py

################################
################### 03 After SCENIC #######################
## Aims:
## 从SCENIC outputs到生物学假设
## Input data: PBMC (ctrl vs INFB simulated)
## 1. 受到INFB影响最大的PBMC细胞类型是什么?        | cellular level
## 2. 哪些TF驱动了INFB simulated PBMC的转录组变化? | Molecular level
## 3. 哪些TF驱动了哪些细胞类型的什么样的变化?
##    (下游的基因, related to某些生物学功能)       | Functional level

library(Seurat)
library(tidyverse)
library(patchwork)
setwd("/home/server/data1/jyz/Ctrl_EcO/20pySCENIC/")
source("/home/server/data1/gzsx/scRNA/grn-new/R/compute_module_score.R")

############# Q1 ###################

## 导入Seurat对象
#load("/home/server/data1/jyz/Ctrl_EcO/01RDada/06_scRNA_harmony_singler20240621.Rdata")
seu <- scRNA_harmony_singler2
## 导入regulon (gene list)
regulons <- clusterProfiler::read.gmt("02-ifnb_pbmc.regulons.gmt")
## data.frame -> list, list中的每个元素为一个gene set
rg.names <- unique(regulons$term)
regulon.list <- lapply(rg.names, function(rg) {
  subset(regulons, term == rg)$gene
})
names(regulon.list) <- sub("[0-9]+g", "\\+", rg.names)
summary(sapply(regulon.list, length))
print(regulon.list[1])
saveRDS(regulon.list, "03-1.ifnb_pbmc.regulons.rds")

## 用AUCell计算RAS matrix
## RAS = regulon activity score
seu <- ComputeModuleScore(seu, gene.sets = regulon.list, min.size = 10, cores = 60)
seu
DefaultAssay(seu) <- "AUCell"

p1 <- FeaturePlot(seu, features = "STAT2(+)", split.by = "group")
p2 <- FeaturePlot(seu, features = "STAT2", split.by = "group")
(p1 / p2) & scale_color_viridis_c()

## 用RAS matrix计算UMAP
seu <- RunUMAP(object = seu,
               features = rownames(seu),
               metric = "correlation", # 注意这里用correlation效果最好
               reduction.name = "umapRAS",
               reduction.key = "umapRAS_")

## 可视化：UMAP on harmony
seu@meta.data$celltype<-seu@meta.data$singleRnew
p1 <- DimPlot(seu, reduction = "umap", group.by = "celltype") + ggsci::scale_color_d3("category20") + NoLegend()
p2 <- DimPlot(seu, reduction = "umap", group.by = "group") + NoLegend()

## 可视化：UMAP on RAS
p3 <- DimPlot(seu, reduction = "umapRAS", group.by = "celltype") + ggsci::scale_color_d3("category20")
p4 <- DimPlot(seu, reduction = "umapRAS", group.by = "group")
pdf("04.pdf")
(p1 + p3) / (p2 + p4)
dev.off()
## 推测：INFB对髓系细胞的影响更大

## 换一种方式：PCA
DefaultAssay(seu) <- "AUCell"
seu <- ScaleData(seu)
seu <- RunPCA(object = seu,
              features = rownames(seu),
              reduction.name = "pcaRAS",
              reduction.key = "pcaRAS_")

## 可视化：PCA on RAS
p3 <- DimPlot(seu, reduction = "pcaRAS", group.by = "celltype") + ggsci::scale_color_d3("category20")
p4 <- DimPlot(seu, reduction = "pcaRAS", group.by = "group")
pdf("05.pdf",width=12,height=6)
p3 + p4
dev.off()
## PC1 encoding the regulons related to cell type
## PC2 encoding the regulons affected by group  对照和病理组
## The INFB induced transcriptome shift is orthogonal to the cell identity transcritional programs.

############# Q2 ###################
## PC2 high loading regulons
seu[["pcaRAS"]]@feature.loadings[, 2] %>% sort() %>% head()
seu[["pcaRAS"]]@feature.loadings[, 2] %>% sort() %>% tail()

p1 <- FeaturePlot(seu, reduction = "pcaRAS", features = "STAT1(+)")
p2 <- FeaturePlot(seu, reduction = "pcaRAS", features = "STAT1")
(p1 | p2) & scale_color_viridis_c()

p1 <- FeaturePlot(seu, reduction = "pcaRAS", features = "EP300(+)")
p2 <- FeaturePlot(seu, reduction = "pcaRAS", features = "EP300")
(p1 | p2) & scale_color_viridis_c()

## regulon module
rasMat <- seu[["AUCell"]]@data
rasMat <- t(rasMat)
pccMat <- cor(rasMat) # 对列计算相关性

# 计算Connection Specificity Index (CSI)
CSI <- function(r1, r2) {
  delta <- pccMat[r1,r2]
  r.others <- setdiff(colnames(pccMat), c(r1,r2))
  N <- sum(pccMat[r1, r.others] < delta) + sum(pccMat[r2, r.others] < delta)
  M <- length(r.others) * 2
  return(N/M)
}

csiMat <- pbapply::pblapply(rownames(pccMat), function(i) sapply(colnames(pccMat), function(j) CSI(i, j)))
csiMat <- do.call(rbind, csiMat)
rownames(csiMat) <- rownames(pccMat)

## 找到一个合适的h for cut tree
library(dendextend)
library(ggsci)
h = 7
row_dend = as.dendrogram(hclust(dist(pccMat), method = "complete"))
clusters <- dendextend::cutree(row_dend, h = h) # dendextend::cutree()
row_dend = color_branches(row_dend, h = h, col = pal_d3("category20")(20))
plot(row_dend)

## 聚类可视化
library(ComplexHeatmap)
library(circlize)

col_range = c(0, 1)
col_fun <- colorRamp2(col_range, c("#FCF8DE", "#253177"))

for(i in nrow(pccMat)) {
  pccMat[i, i] <- 0
}
pdf("06.pdf",width=10,height=10)
ht <- Heatmap(
  matrix = pccMat,
  col = col_fun,
  name = "ht1",
  cluster_rows = TRUE,
  cluster_columns = TRUE,
  show_column_names = FALSE,
  show_row_names = FALSE,
  show_heatmap_legend = FALSE
)

lgd <- Legend(
  col_fun = col_fun,
  title = "",
  at = col_range,
  labels = c("low", "high"),
  direction = "horizontal",
  legend_width = unit(1, "in"),
  border = FALSE
)

{
  draw(ht, heatmap_legend_list = list(lgd), heatmap_legend_side = c("bottom"))
  decorate_heatmap_body("ht1", {
    tree = column_dend(ht)
    ind = cutree(as.hclust(tree), h = h)[order.dendrogram(tree)]
    first_index = function(l) which(l)[1]
    last_index = function(l) { x = which(l); x[length(x)] }
    clusters <- names(table(ind))
    x1 = sapply(clusters, function(x) first_index(ind == x)) - 1
    x2 = sapply(clusters, function(x) last_index(ind == x))
    x1 = x1/length(ind)
    x2 = x2/length(ind)
    grid.rect(x = x1, width = (x2 - x1), y = 1-x1, height = (x1 - x2),
              hjust = 0, vjust = 0, default.units = "npc",
              gp = gpar(fill=NA, col="#FCB800", lwd=3))
    grid.text(label = paste0("M",clusters),
              x = x2-length(clusters)/length(ind), y = 1-x1-(x2-x1)/2,
              default.units = "npc",
              hjust = 1, vjust = 0.5,
              gp = gpar(fontsize=12, fontface="bold"))
  })
  decorate_column_dend("ht1", {
    tree = column_dend(ht)
    ind = cutree(as.hclust(tree), h = h)[order.dendrogram(tree)]
    first_index = function(l) which(l)[1]
    last_index = function(l) { x = which(l); x[length(x)] }
    clusters <- names(table(ind))
    x1 = sapply(clusters, function(x) first_index(ind == x)) - 1
    x2 = sapply(clusters, function(x) last_index(ind == x))
    grid.rect(x = x1/length(ind), width = (x2 - x1)/length(ind), just = "left",
              default.units = "npc", gp = gpar(fill = pal_d3("category20")(20), alpha=.5, col = NA))
  })
}
dev.off()
tree <- column_dend(ht)
ind <- cutree(as.hclust(tree), h = h)[order.dendrogram(tree)]
clusters <- names(table(ind))
regulon.clusters <- data.frame(regulon=names(ind), cluster=paste0("M",ind))
table(regulon.clusters$cluster)
regulon.clusters
saveRDS(regulon.clusters, "03-2.ifnb_pbmc.regulon_modules.rds")

# 绘制每个regulon-module的平均活性
k = length(clusters)
cell.info <- seu@meta.data
moduleRasMat <- lapply(paste0("M",1:k), function(x){
  regulon.use <- subset(regulon.clusters, cluster == x)$regulon
  rowMeans(rasMat[, regulon.use, drop=FALSE])
})
names(moduleRasMat) <- paste0("M",1:k)
moduleRasMat <- do.call(cbind, moduleRasMat)
cell.info <- cbind(cell.info, moduleRasMat[rownames(cell.info), ])

cell.info <- cbind(cell.info, seu@reductions$umap@cell.embeddings)

p.list <- lapply(paste0("M",1:k), function(module){
  data.use <- cell.info
  expression.color <- c("darkblue", "lightblue", "green", "yellow", "red")
  max.val <- quantile(data.use[, module], 0.99)
  low.val <- quantile(data.use[, module], 0.1)
  data.use[, module] <- ifelse(data.use[, module] > max.val, max.val, data.use[, module])
  ggplot(data.use, aes(UMAP_1, UMAP_2, color=get(module))) +
    geom_point(size=0.05) +
    theme_bw(base_size = 15) +
    ggtitle(module) +
    facet_wrap(~group) +
    scale_color_gradientn(name = NULL, colors = expression.color) +
    theme(legend.position = "right",
          legend.title = element_blank(),
          plot.title = element_text(hjust = .5, face = "bold", size = 20),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          axis.line = element_line(color="black")
    )
})
pdf("07.pdf",width=90,height=30)
cowplot::plot_grid(plotlist = p.list, ncol = 3)
dev.off()
pdf("08.pdf",width=60,height=18)
cowplot::plot_grid(plotlist = p.list, ncol = 3)
dev.off()
pdf("09.pdf",width=45,height=15)
cowplot::plot_grid(plotlist = p.list, ncol = 3)
dev.off()
############# Q3 ###################
## TF module: a list of regulons
## regulon:   a list of genes
## genes?? enrichment !!

## TF module 展开成一个基因集合 + 富集分析 = 外源信号 -> TF -> 功能基因
regulon.clusters <- readRDS("03-2.ifnb_pbmc.regulon_modules.rds")

rms <- unique(regulon.clusters$cluster)
module.list <- lapply(rms, function(xx) subset(regulon.clusters, cluster == xx)$regulon)
names(module.list) <- rms

regulon.list <- readRDS("03-1.ifnb_pbmc.regulons.rds")

regulon.module.genes <- lapply(seq_along(module.list), function(xx) {
  unique(unlist(regulon.list[module.list[[xx]] ]))
})
names(regulon.module.genes) <- names(module.list)

sapply(regulon.module.genes, length)

## 富集分析
library(clusterProfiler)
load("../GSEA annotation MSigDB genesets.RData")
t2g <- GOBP

eres.list <- lapply(sort(names(regulon.module.genes)), function(clu) {
  message(glue::glue("processing {clu} ..."))
  genes <- regulon.module.genes[[clu]]
  ## downsample to speed up the calculation
  if (length(genes) >= 200) {
    genes <- sample(genes, size = 200)
  }
  clusterProfiler::enricher(gene = genes, TERM2GENE = t2g, pvalueCutoff = 1, minGSSize = 0)
})
names(eres.list) <- sort(names(regulon.module.genes))

## plot data
data.use <- lapply(names(eres.list), function(xx) {
  res <- subset(eres.list[[xx]]@result, grepl("^GOBP_", ID)) # only show GO results
  res <- head(res, 5)
  res$group <- xx
  res
}) %>% Reduce(rbind, .)

term.levels <- unique(data.use$Description)

data.use <- lapply(names(eres.list), function(xx) {
  res <- subset(eres.list[[xx]]@result, Description %in% term.levels)
  res$group <- xx
  res
}) %>% Reduce(rbind, .)

data.use$Description <- factor(data.use$Description, levels = rev(term.levels))
data.use <- subset(data.use, p.adjust < 0.05 & Count > 2)

## plot
pdf("10.pdf")
ggplot(data.use, aes(group, Description)) +
  geom_point(aes(size = Count, fill = -log10(p.adjust)), shape=21, color = "black") +
  scale_fill_gradientn(colors = c("white","red")) +
  scale_y_discrete(labels = function(x) str_wrap(x, width = 50)) +
  labs(x = "gene cluster") +
  theme_bw(base_size = 13) +
  theme(axis.title.y = element_blank(),
        axis.text = element_text(color = "black"))
dev.off()
qs::qsave(eres.list, "03-3.ifnb_pbmc.regulon_modules.enriched_terms.qs")
rm(scRNA_harmony_singler2)
save.image("20240708.Rdata")







########################################################################scMLnet画网络图
#################################单一跑法
               Adipocytes                   B cells           dendritic cells
                       49                      3939                       569
          Dendritic cells         Endothelial cells          Epithelial cells
                       39                      1308                      1207
             Granulocytes               Macrophages                 Monocytes
                     2028                      4053                      1045
                 NK cells       Smooth muscle cells Stem and progenitor cells
                      509                       389                       662
            Stromal cells                   T cells
                     3242                      2872


conda activate scMLnet
cd /public/workspace/lincs/me/yao/20scMLnet/
export OPENBLAS_NUM_THREADS=20
export GOTO_NUM_THREADS=20
export OMP_NUM_THREADS=20
R
library(Seurat)
library(Matrix)
library(parallel)
library(scMLnet)
load("/public/workspace/lincs/me/yao/01RDada/02_scRNA_harmony_singler.Rdata")
scRNA<-scRNA_harmony_singler
BarCluFile=as.data.frame(scRNA@meta.data[,"singleRnew",drop=F])
colnames(BarCluFile)="Cluster"
out=cbind(Barcode=rownames(BarCluFile),BarCluFile)
write.table(out,file="cellType.txt",sep="\t",quote=F,row.names=F)  ##列名修改成Barcode和Cluster用于RunMLnet函数

expr<-scRNA@assays$RNA@data
rownames(expr)<-toupper(rownames(expr))
##前面我认为是矩阵文件，不是稀疏矩阵，其实不用转换，就是稀疏矩阵文件。

pval <- 0.05
logfc <- 0.15
LigClu <- "Stromal cells"    #研究关注提供配体的细胞亚群
RecClu <- "Dendritic cells"  #研究关注提供受体的细胞亚群
workdir <- "scMLnet/"#输出结果路径位置
LigRecLib = "./database/LigRec.txt"
TFTarLib = "./database/TFTargetGene.txt"
RecTFLib = "./database/RecTF.txt"
netList <- RunMLnet(expr, "cellType.txt", RecClu, LigClu,pval, logfc,LigRecLib, TFTarLib, RecTFLib)
workdir <- "sample"
#会在out文件夹下创建sample文件夹，再在sample文件夹中创建文件夹，两种细胞，里面有3个文件，这3个文件用以画图
DrawMLnet(netList,LigClu,RecClu,workdir,plotMLnet = F)

####################################循环跑法---stromal 作为配体
               Adipocytes                   B cells           dendritic cells
                       49                      3939                       569
          Dendritic cells         Endothelial cells          Epithelial cells
                       39                      1308                      1207
             Granulocytes               Macrophages                 Monocytes
                     2028                      4053                      1045
                 NK cells       Smooth muscle cells Stem and progenitor cells
                      509                       389                       662
            Stromal cells                   T cells
                     3242                      2872


conda activate scMLnet
cd /public/workspace/lincs/me/yao/20scMLnet/
export OPENBLAS_NUM_THREADS=20
export GOTO_NUM_THREADS=20
export OMP_NUM_THREADS=20
R
library(Seurat)
library(Matrix)
library(parallel)
library(scMLnet)
load("/public/workspace/lincs/me/yao/01RDada/02_scRNA_harmony_singler.Rdata")
scRNA<-scRNA_harmony_singler
BarCluFile=as.data.frame(scRNA@meta.data[,"singleRnew",drop=F])
colnames(BarCluFile)="Cluster"
out=cbind(Barcode=rownames(BarCluFile),BarCluFile)
write.table(out,file="cellType.txt",sep="\t",quote=F,row.names=F)  ##列名修改成Barcode和Cluster用于RunMLnet函数

expr<-scRNA@assays$RNA@data
rownames(expr)<-toupper(rownames(expr))
##前面我认为是矩阵文件，不是稀疏矩阵，其实不用转换，就是稀疏矩阵文件。

pval <- 0.05
logfc <- 0.15
LigClu <- "Stromal cells"    #研究关注提供配体的细胞亚群
#研究关注提供受体的细胞亚群
workdir <- "scMLnet/"#输出结果路径位置
LigRecLib = "./database/LigRec.txt"
TFTarLib = "./database/TFTargetGene.txt"
RecTFLib = "./database/RecTF.txt"

for (i in c("Adipocytes","B cells","dendritic cells","Dendritic cells","Epithelial cells","Granulocytes","Macrophages","Monocytes","NK cells","Smooth muscle cells", "Stem and progenitor cells","T cells","Stromal cells")){
#研究关注提供受体的细胞亚群
RecClu <- i
netList <- RunMLnet(expr, "cellType.txt", RecClu, LigClu,pval, logfc,LigRecLib, TFTarLib, RecTFLib)
workdir <- "sample"
#会在out文件夹下创建sample文件夹，再在sample文件夹中创建文件夹，两种细胞，里面有3个文件，这3个文件用以画图
DrawMLnet(netList,LigClu,RecClu,workdir,plotMLnet = F)
}

###########################################
####################################循环跑法---stromal 作为受体
               Adipocytes                   B cells           dendritic cells
                       49                      3939                       569
          Dendritic cells         Endothelial cells          Epithelial cells
                       39                      1308                      1207
             Granulocytes               Macrophages                 Monocytes
                     2028                      4053                      1045
                 NK cells       Smooth muscle cells Stem and progenitor cells
                      509                       389                       662
            Stromal cells                   T cells
                     3242                      2872


conda activate scMLnet
cd /public/workspace/lincs/me/yao/20scMLnet/
export OPENBLAS_NUM_THREADS=20
export GOTO_NUM_THREADS=20
export OMP_NUM_THREADS=20
R
library(Seurat)
library(Matrix)
library(parallel)
library(scMLnet)
load("/public/workspace/lincs/me/yao/01RDada/02_scRNA_harmony_singler.Rdata")
scRNA<-scRNA_harmony_singler
BarCluFile=as.data.frame(scRNA@meta.data[,"singleRnew",drop=F])
colnames(BarCluFile)="Cluster"
out=cbind(Barcode=rownames(BarCluFile),BarCluFile)
write.table(out,file="cellType.txt",sep="\t",quote=F,row.names=F)  ##列名修改成Barcode和Cluster用于RunMLnet函数

expr<-scRNA@assays$RNA@data
rownames(expr)<-toupper(rownames(expr))
##前面我认为是矩阵文件，不是稀疏矩阵，其实不用转换，就是稀疏矩阵文件。

pval <- 0.05
logfc <- 0.15
RecClu<- "Stromal cells"    #研究关注提供配体的细胞亚群
#研究关注提供受体的细胞亚群
workdir <- "scMLnet/"#输出结果路径位置
LigRecLib = "./database/LigRec.txt"
TFTarLib = "./database/TFTargetGene.txt"
RecTFLib = "./database/RecTF.txt"

for (i in c("Adipocytes","B cells","dendritic cells","Dendritic cells","Epithelial cells","Endothelial cells","Granulocytes","Macrophages","Monocytes","NK cells","Smooth muscle cells", "Stem and progenitor cells","T cells","Stromal cells")){
#研究关注提供受体的细胞亚群
LigClu  <- i
netList <- RunMLnet(expr, "cellType.txt", RecClu, LigClu,pval, logfc,LigRecLib, TFTarLib, RecTFLib)
workdir <- "sample2"
#会在out文件夹下创建sample2文件夹，再在sample文件夹中创建文件夹，两种细胞，里面有3个文件，这3个文件用以画图
DrawMLnet(netList,LigClu,RecClu,workdir,plotMLnet = F)
}





####
conda activate scMLnet3
cd /public/workspace/lincs/me/yao/20scMLnet/output/sample/Stromal_Endothelial/
NetLigRecFile=./LigRec.net.txt
NetTFTarFile=./TFTarGene.net.txt
NetRecTFFile=./RecTF.net.txt
netPic=./mulnet.pdf
python ../../../code/DrawNetNew.py $NetLigRecFile $NetRecTFFile $NetTFTarFile $netPic



##################################################21enrich  IL1
cd /public/workspace/lincs/me/
singularity shell lcs_rnaseq20231229.sif
cd /public/workspace/lincs/me/yao/
R
setwd("/public/workspace/lincs/me/yao/")
###加载所需要的包

set.seed(123456)
if (!dir.exists("21enrich")){
dir.create("21enrich")
}
setwd("./21enrich")
load("/public/workspace/lincs/me/yao/01RDada/02_scRNA_harmony_singler.Rdata")
library(ggplot2)
library(Seurat)
library(dplyr)
library(reticulate)
library(cowplot)
library(viridis)
library(tidyr)
library(magrittr)
library(reshape2)
library(readxl)
library(stringr)
library(cowplot)
library(scales)
library(tibble)
library(gplots)
library(RColorBrewer)

library(clusterProfiler)
Hallmarker <- read.gmt("../KEGG_MEDICUS_REFERENCE_IL1_IL1R_JNK_SIGNALING_PATHWAY.v2023.2.Hs.gmt") 
broad_pws <- split(Hallmarker$gene,Hallmarker$term)
broad_pws <- lapply(unique(Hallmarker$term), function(x){Hallmarker$gene[Hallmarker$term == x]})
names(broad_pws) <- unique(Hallmarker$term)
broad_pws[[1]]<-stringr::str_to_title(broad_pws[[1]])

scRNA_harmony_singler <- AddModuleScore(object = scRNA_harmony_singler, features = broad_pws, name = names(broad_pws))

# 简单可视化
pdf("FeaturePlot_IL1_IL1R_JNK_SIGNALING_PATHWAY.pdf")
FeaturePlot(scRNA_harmony_singler, features = c('KEGG_MEDICUS_REFERENCE_IL1_IL1R_JNK_SIGNALING_PATHWAY1'),split.by = 'group' )
dev.off()
pdf("DotPlot_IL1_IL1R_JNK_SIGNALING_PATHWAY.pdf")
DotPlot(scRNA_harmony_singler, features = c('KEGG_MEDICUS_REFERENCE_IL1_IL1R_JNK_SIGNALING_PATHWAY1'))
dev.off()

Hallmarker <- read.gmt("../KEGG_MEDICUS_REFERENCE_IL1_IL1R_P38_SIGNALING_PATHWAY.v2023.2.Hs.gmt") 
broad_pws <- split(Hallmarker$gene,Hallmarker$term)
broad_pws <- lapply(unique(Hallmarker$term), function(x){Hallmarker$gene[Hallmarker$term == x]})
names(broad_pws) <- unique(Hallmarker$term)
broad_pws[[1]]<-stringr::str_to_title(broad_pws[[1]])
scRNA_harmony_singler <- AddModuleScore(object = scRNA_harmony_singler, features = broad_pws, name = names(broad_pws))

# 简单可视化
pdf("FeaturePlot_IL1_IL1R_JNK_SIGNALING_PATHWAY.pdf")
FeaturePlot(scRNA_harmony_singler, features = c('KEGG_MEDICUS_REFERENCE_IL1_IL1R_JNK_SIGNALING_PATHWAY1'),split.by = 'group' )
dev.off()
pdf("DotPlot_IL1_IL1R_JNK_SIGNALING_PATHWAY.pdf")
DotPlot(scRNA_harmony_singler, features = c('KEGG_MEDICUS_REFERENCE_IL1_IL1R_JNK_SIGNALING_PATHWAY1'))
dev.off()


##################################################22coexpr  IL1


set.seed(123456)
if (!dir.exists("22coexpr")){
dir.create("22coexpr")
}
setwd("./22coexpr")
load("/public/workspace/lincs/me/yao/01RDada/02_scRNA_harmony_singler.Rdata")
# FeaturePlot绘制UMAP图上共表达基因展示，blend设置为TRUE
FeaturePlot(scRNA_harmony_singler, features = c("Il1b", "Il33"), 
            blend = TRUE, 
            cols = c("gray80","red", "green"), 
            pt.size = 0.5, raster = F) +  
  theme(aspect.ratio = 1)
ggsave("UMAP_co-expression matrix.pdf", width = 12, height = 4)

getScatterplot <- function(object, gene1, gene2, cor.method = "spearman",
                           jitter.num = 0.15, pos = TRUE){
  if (!gene1 %in% rownames(object)) {
    print("gene1 was not found")
    if (!gene2 %in% rownames(object)) {
      print("gene2 was not found")
    }
  }else{
    exp.mat <- GetAssayData(object = object, assay = "RNA") %>% .[c(gene1,gene2),] %>% 
      as.matrix() %>% t() %>% as.data.frame()
    if (pos) {
      exp.mat <- exp.mat[which(exp.mat[,1] > 0 & exp.mat[,2] > 0),]
    }
    plots <- ggplot(data=exp.mat, mapping = aes_string(x = gene1, y = gene2)) + 
      geom_smooth(method = 'lm', se = T, color='red', size=1)+
      stat_cor(method = cor.method)+ 
      geom_jitter(width = jitter.num, height = jitter.num, color = "black", size = 1, alpha=1)+
      theme_bw()+
      theme(panel.grid=element_blank(),
            legend.text=element_text(colour= 'black',size=10),
            axis.text= element_text(colour= 'black',size=10),
            axis.line= element_line(colour= 'black'),
            panel.border = element_rect(size = 1, linetype = "solid", colour = "black"),
            panel.background=element_rect(fill="white"))
    return(plots)
  }
}
library(ggplot2)
library(ggpubr)
library(patchwork)
library(magrittr)
getScatterplot(scRNA_harmony_singler, gene1 = "Il1b", gene2 = "Il33", 
               jitter.num = 0.15, pos = TRUE) +
  theme(aspect.ratio = 1)
ggsave("correlation_dotplot.pdf")
getScatterplot(scRNA_harmony_singler, gene1 = "Il1b", gene2 = "Il33", 
               jitter.num = 0, pos = FALSE) +
  theme(aspect.ratio = 1)
ggsave("correlation_Scatterplot.pdf")  
#########################################################################################AUCell计算每个细胞中缺氧通路的富集值
##BiocManager::install("AUCell")
library(AUCell)
library(ggplot2)
library(Seurat)
library(clusterProfiler)
library(GSVA)
library(AUCell)
#BiocManager::install(c("doMC", "doRNG","doSNOW"))
# For the main example:
#BiocManager::install(c("mixtools", "GEOquery", "SummarizedExperiment"))
# For the examples in the follow-up section of the tutorial:
#BiocManager::install(c("DT", "plotly", "NMF", "d3heatmap", "shiny", "rbokeh", "dynamicTreeCut","R2HTML","Rtsne", "zoo"))
##install.packages('doMC')
##install.packages("doRNG")
sc2=scRNA_harmony
Idents(sc2)<-sc2@meta.data$newgroup
cells_rankings <- AUCell_buildRankings(sc2@assays$RNA@data, nCores=2, plotStats=TRUE) 


c2 <- read.gmt("h.all.v7.4.symbols.gmt") 
geneSets <- lapply(unique(c2$term), function(x){print(x);c2$gene[c2$term == x]})
names(geneSets) <- unique(c2$term)
cells_AUC <- AUCell_calcAUC(geneSets, cells_rankings,nCores =1, aucMaxRank=nrow(cells_rankings)*0.1)
###如果是小鼠数据用下面代码
#library(msigdbr)
#m_df<- msigdbr(species = "Mus musculus",  category = "C2", subcategory = "KEGG")
#fgsea_sets<- m_df %>% split(x = .$gene_symbol, f = .$gs_name)


#cells_AUC <- AUCell_calcAUC(fgsea_sets, cells_rankings,nCores =1, aucMaxRank=nrow(cells_rankings)*0.1)
#grep("OX",rownames(cells_AUC@assays@data$AUC),value = T)

geneSet <- "HALLMARK_HYPOXIA"
aucs <- as.numeric(getAUC(cells_AUC)[geneSet, ])
sc2$AUC <- aucs
df<- data.frame(sc2@meta.data, sc2@reductions$umap@cell.embeddings)
colnames(df)
class_avg <- df %>%
  group_by( seurat_clusters) %>%
  summarise(
    UMAP_1 = median(UMAP_1),
    UMAP_2 = median(UMAP_2)
  )

p<-ggplot(df, aes(UMAP_1, UMAP_2))  +
  geom_point(aes(colour  = AUC)) + viridis::scale_color_viridis(option="D") +
  ggrepel::geom_label_repel(aes(label = seurat_clusters),
                            data = class_avg,
                            size = 5,
                            label.size = 1,
                            segment.color = NA
  )+   theme(legend.position = "none") + theme_bw()
ggsave(file="HALLMARK_HYPOXIA_umap.pdf",plot=p,width=8,height=8)
######################下面把缺氧得分分成高低
save(scRNA_harmony,file='scRNA_harmony_auc.Rdata')


########################################################################################################3
#单独保存3T样本
scRNA_harmony_3T<-subset(scRNA_harmony,subset=orig.ident=="3T")
#把肿瘤样本中的肿瘤细胞抽取出来
scRNA_harmony_3T_tumorcell<-subset(scRNA_harmony_3T,subset=singleR=="Epithelial_cells")
auc2<-scRNA_harmony_3T_tumorcell@meta.data$AUC
group_list<-ifelse(aucs2<mean(auc2),"low","high")
scRNA_harmony_3T_tumorcell@meta.data$AUC_grade<-as.factor(group_list)



barcodes1<-colnames(scRNA_harmony_3T)

singlernames<-as.character(scRNA_harmony_3T$singleR)
df1<-data.frame(barcodes1=barcodes1,singlernames=singlernames)



barcodes2<-colnames(scRNA_harmony_3T_tumorcell)

auc_hy<-as.character(scRNA_harmony_3T_tumorcell@meta.data$AUC_grade)
auc_hy2<-paste0("cancer_hypoxia_",auc_hy)
df2<-data.frame(barcodes2=barcodes2,singlernames2=auc_hy2)

df1$singleR_tumor_grade<-df1$singlernames
k=dim(df1)[1]
for (i in 1:k){ if(df1$singleR_tumor_grade[i]=="Epithelial_cells"){df1$singleR_tumor_grade[i]=df2$singlernames2[which(df2$barcodes2==df1$barcodes1[i])]}}
scRNA_harmony_3T@meta.data$singleR_tumor_grade<-as.factor(df1$singleR_tumor_grade)


##########################################跑cellphonedb##################################################

write.table(as.matrix(scRNA_harmony_3T@assays$RNA@data), 'T3dataforcellphonedb.txt', sep='\t', quote=F)
meta_data <- cbind(rownames(scRNA_harmony_3T@meta.data), scRNA_harmony_3T@meta.data[,'singleR_tumor_grade', drop=F])  
meta_data <- as.matrix(meta_data)
meta_data[is.na(meta_data)] = "Unkown" #  细胞类型中不能有NA

write.table(meta_data, 'T3metaforcellphonedb.txt', sep='\t', quote=F, row.names=F)




write.table(as.matrix(scRNA_harmony_3T@assays$RNA@data), 'T3dataforcellphonedb.txt', sep='\t', quote=F)


Cell1<-colnames(scRNA_harmony_3T)
cell_type<-as.character(scRNA_harmony_3T@meta.data$singleR_tumor_grade)
metadata1<-data.frame(Cell=Cell1,cell_type=cell_type)
write.table(metadata1,file="T3metaforcellphonedb.txt",quote=F,col.names=T,row.names=F,sep="\t")


save(scRNA_harmony_3T,file='scRNA_harmony_3T.Rdata')
save(scRNA_harmony_3T_tumorcell,file='scRNA_harmony_3T_tumorcell.Rdata')

####################肿瘤缺氧高低两组的GSEA
#加载需要的R包
library(Seurat)
library(msigdbr)
library(GSVA)
library(tidyverse)
library(clusterProfiler)
library(patchwork)
library(fgsea)
library(dplyr)
library(ggplot2)


#加载单个样本单细胞数据分析结果
load("scRNA_harmony_3T_tumorcell.Rdata")
Idents(scRNA_harmony_3T_tumorcell)<-scRNA_harmony_3T_tumorcell@meta.data$AUC_grade
scRNA<-scRNA_harmony_3T_tumorcell
#挑选B细胞相对于CD8T细胞特意性高表达的marker基因
B_vs_CD8T=FindMarkers(scRNA, ident.1="low",ident.2="high",only.pos = F, min.pct = 0.25, logfc.threshold = 0.25)
#制作geneList
#值为log2FC
geneList= B_vs_CD8T$avg_log2FC 
#name为基因名字
names(geneList)= rownames(B_vs_CD8T)
#按FC从大到小排序
geneList=sort(geneList,decreasing = T)
head(geneList)


#从GSEA官网下载GSEA分析需要的基因集
#http://www.gsea-msigdb.org/gsea/index.jsp

#下载免疫相关的基因集，c7: immunologic signature gene sets
gmtfile ='h.all.v7.4.symbols.gmt'

#读取gmt文件中的pathway信息
pathway<-read.gmt(gmtfile)
#进行GSEA分析
y <- GSEA(geneList,TERM2GENE =pathway)

#保存GSEA分析结果
write.csv(file="B_vs_CD8T_GSEA_result.csv",data.frame(y))

#气泡图展示显著富集的前20条通路
pdf(file="GSEA_high_low_dotplot.pdf",width=15)
dotplot(y,showCategory=20)
dev.off()





#geneid<-rownames(scRNA_harmony_3T)
#data2<-scRNA_harmony_3T@assays$RNA@data
#data1<-data.frame(gene<-geneid)
#data3<-cbind(data1,data2)
#write.table(data3,file="T3dataforcellphonedb.txt",quote=F,col.names=T,row.names=F,sep="\t")



####cellphonedb运行，在dell服务器中，sif运行，下面是运行代码
cellphonedb method statistical_analysis T3metaforcellphonedb.txt T3dataforcellphonedb.txt --counts-data=gene_name --output-path cellphonedbout 

############################################################################cell 数据 cellranger
singularity shell /public/workspace/lincs/lab7/cellranger/cellranger_6.1.2.sif
cd /public/workspace/lincs/me/oral/cell/SRX9777390/

cellranger count --id=run_count_SRX9777392 --fastqs=/public/workspace/lincs/me/oral/cell/SRX9777392/fq/ --sample=SRX9777392 --transcriptome=/public/workspace/lincs/lab7/cellranger/ref/refdata-gex-GRCh38-2020-A/


SRX9777391_S1_L001_I1_001.fastq.gz
SRX9777391_S1_L001_R1_001.fastq.gz
SRX9777391_S1_L001_R2_001.fastq.gz

SRX9777391_S1_L002_I1_001.fastq.gz
SRX9777391_S1_L002_R1_001.fastq.gz
SRX9777391_S1_L002_R2_001.fastq.gz

SRX9777391_S1_L003_I1_001.fastq.gz
SRX9777391_S1_L003_R1_001.fastq.gz
SRX9777391_S1_L003_R2_001.fastq.gz

SRX9777391_S1_L004_I1_001.fastq.gz
SRX9777391_S1_L004_R1_001.fastq.gz
SRX9777391_S1_L004_R2_001.fastq.gz
#########################################
SRX9777392_S1_L001_I1_001.fastq.gz
SRX9777392_S1_L001_R1_001.fastq.gz
SRX9777392_S1_L001_R2_001.fastq.gz

SRX9777392_S1_L002_I1_001.fastq.gz
SRX9777392_S1_L002_R1_001.fastq.gz
SRX9777392_S1_L002_R2_001.fastq.gz

SRX9777392_S1_L003_I1_001.fastq.gz
SRX9777392_S1_L003_R1_001.fastq.gz
SRX9777392_S1_L003_R2_001.fastq.gz

SRX9777392_S1_L004_I1_001.fastq.gz
SRX9777392_S1_L004_R1_001.fastq.gz
SRX9777392_S1_L004_R2_001.fastq.gz

#########################################
SRX9777393_S1_L001_I1_001.fastq.gz
SRX9777393_S1_L001_R1_001.fastq.gz
SRX9777393_S1_L001_R2_001.fastq.gz

SRX9777393_S1_L002_I1_001.fastq.gz
SRX9777393_S1_L002_R1_001.fastq.gz
SRX9777393_S1_L002_R2_001.fastq.gz

SRX9777393_S1_L003_I1_001.fastq.gz
SRX9777393_S1_L003_R1_001.fastq.gz
SRX9777393_S1_L003_R2_001.fastq.gz

SRX9777393_S1_L004_I1_001.fastq.gz
SRX9777393_S1_L004_R1_001.fastq.gz
SRX9777393_S1_L004_R2_001.fastq.gz


#########################################
SRX9777394_S1_L001_I1_001.fastq.gz
SRX9777394_S1_L001_R1_001.fastq.gz
SRX9777394_S1_L001_R2_001.fastq.gz

SRX9777394_S1_L002_I1_001.fastq.gz
SRX9777394_S1_L002_R1_001.fastq.gz
SRX9777394_S1_L002_R2_001.fastq.gz

SRX9777394_S1_L003_I1_001.fastq.gz
SRX9777394_S1_L003_R1_001.fastq.gz
SRX9777394_S1_L003_R2_001.fastq.gz

SRX9777394_S1_L004_I1_001.fastq.gz
SRX9777394_S1_L004_R1_001.fastq.gz
SRX9777394_S1_L004_R2_001.fastq.gz

#########################################
SRX9777395_S1_L001_I1_001.fastq.gz
SRX9777395_S1_L001_R1_001.fastq.gz
SRX9777395_S1_L001_R2_001.fastq.gz

SRX9777395_S1_L002_I1_001.fastq.gz
SRX9777395_S1_L002_R1_001.fastq.gz
SRX9777395_S1_L002_R2_001.fastq.gz

SRX9777395_S1_L003_I1_001.fastq.gz
SRX9777395_S1_L003_R1_001.fastq.gz
SRX9777395_S1_L003_R2_001.fastq.gz

SRX9777395_S1_L004_I1_001.fastq.gz
SRX9777395_S1_L004_R1_001.fastq.gz
SRX9777395_S1_L004_R2_001.fastq.gz

#########################################
SRX9777396_S1_L001_I1_001.fastq.gz
SRX9777396_S1_L001_R1_001.fastq.gz
SRX9777396_S1_L001_R2_001.fastq.gz

SRX9777396_S1_L002_I1_001.fastq.gz
SRX9777396_S1_L002_R1_001.fastq.gz
SRX9777396_S1_L002_R2_001.fastq.gz

SRX9777396_S1_L003_I1_001.fastq.gz
SRX9777396_S1_L003_R1_001.fastq.gz
SRX9777396_S1_L003_R2_001.fastq.gz

SRX9777396_S1_L004_I1_001.fastq.gz
SRX9777396_S1_L004_R1_001.fastq.gz
SRX9777396_S1_L004_R2_001.fastq.gz

#########################################
SRX9777397_S1_L001_I1_001.fastq.gz
SRX9777397_S1_L001_R1_001.fastq.gz
SRX9777397_S1_L001_R2_001.fastq.gz

SRX9777397_S1_L002_I1_001.fastq.gz
SRX9777397_S1_L002_R1_001.fastq.gz
SRX9777397_S1_L002_R2_001.fastq.gz

SRX9777397_S1_L003_I1_001.fastq.gz
SRX9777397_S1_L003_R1_001.fastq.gz
SRX9777397_S1_L003_R2_001.fastq.gz

SRX9777397_S1_L004_I1_001.fastq.gz
SRX9777397_S1_L004_R1_001.fastq.gz
SRX9777397_S1_L004_R2_001.fastq.gz


#############################################################################################cNMF

python部分是用小Y画图的cnmf_env环境跑的，R部分的基因富集没有，重新安装的enrich环境
####第0步R，先准备数据
library(Seurat)
library(tidyverse)

#表达矩阵下载：https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE103322
#样本信息：https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSM2760545
#第二个链接有关于表达矩阵的详细说明，可以知道我们下载得到的矩阵是TPM值。23,686 analyzed genes (rows), across 5902 cells。另外还有五行header注释。
#将该矩阵人为拆分成mat.txt和anno.txt
mat=read.table("mat.txt",header = T,row.names = 1,sep = "\t",stringsAsFactors = F)

anno=read.table("anno.txt",header = T,row.names = 1,sep = "\t")
anno=as.data.frame(t(anno))
colnames(anno)=str_replace_all(colnames(anno)," ","_")
anno$CB=rownames(anno)
#只选择肿瘤细胞；原发灶、淋巴结转移混着做
tumor_anno=anno%>%filter(classified__as_cancer_cell=="1")
tumor_anno$patient=sapply(tumor_anno$CB,function(x){str_split(x,"_")[[1]][1]})
#table(tumor_anno$patient,tumor_anno$Lymph_node)
tumor_anno$patient=str_replace(tumor_anno$patient,"HN25","HNSCC25")
tumor_anno$patient=str_replace(tumor_anno$patient,"HN26","HNSCC26")
tumor_anno$patient=str_replace(tumor_anno$patient,"HN28","HNSCC28")
tumor_anno=tumor_anno%>%filter(patient!="HNSCC")
#sort(table(tumor_anno$patient))
#只选择肿瘤细胞数最多的10个病人
tumor_anno=tumor_anno[tumor_anno$patient %in% names(tail(sort(table(tumor_anno$patient)),10)),]

#提取肿瘤细胞的表达矩阵
tumor_mat=mat[,tumor_anno$CB]

#单细胞标准流程
test.seu=CreateSeuratObject(counts = log(tumor_mat+1))
##因为是TPM数据，已经对文库大小做了标准化，因此不能直接用seurat的NormalizeData函数
##If you have TPM data, you can simply manually log transform the gene expression matrix in the object@data slot before scaling the data.——github
##You have to replace your object@data slot with the desired gene expression matrix as follows: pbmc@data = log(x = norm + 1))——github
##也可以在生成对象的时候就log
test.seu <- FindVariableFeatures(test.seu, selection.method = "vst", nfeatures = 2000)
test.seu <- ScaleData(test.seu)

test.seu <- RunPCA(test.seu, npcs = 50, verbose = FALSE)
test.seu <- FindNeighbors(test.seu, dims = 1:30)
test.seu <- FindClusters(test.seu, resolution = 0.5)
test.seu <- RunUMAP(test.seu, dims = 1:30)
test.seu <- RunTSNE(test.seu, dims = 1:30)

test.seu@meta.data$CB=rownames(test.seu@meta.data)
test.seu@meta.data=inner_join(test.seu@meta.data,tumor_anno,by="CB")
rownames(test.seu@meta.data)=test.seu@meta.data$CB

DimPlot(test.seu, reduction = "tsne", group.by = "patient", pt.size=1, label = TRUE,repel = TRUE)+theme_bw()+theme(panel.grid = element_blank())
ggsave("tsne.pdf",width = 15,height = 12,units = "cm")
#结果不错，和原文一致，可以证明前面的数据提取，及处理是没有问题的

#正式开始
#使用的软件为cNMF，2019年发表在eLife期刊上，链接：https://github.com/dylkot/cNMF
#下载后的cnmf.py就是后面会用到的脚本，建议在单独的conda环境下运行。该软件输入的是count矩阵，cell x genes

#因为本次演示的数据只能下载到TPM矩阵，因此我就直接拿来用了(不是最优，建议不要学我)。
#此外，在运行之前还需要对数据集过滤，排除低质量的基因或细胞

for (pi in unique(test.seu@meta.data$patient)) {
  small.meta=test.seu@meta.data %>% filter(patient==pi)
  small.mat=tumor_mat[,small.meta$CB]
  small.mat=small.mat[,names(colSums(small.mat > 0))[colSums(small.mat > 0) > 2000]] #每个细胞表达多于2000个基因
  small.mat=small.mat[names(rowSums(small.mat > 0))[rowSums(small.mat > 0) > (0.05*dim(small.mat)[2])],] #每个基因在多于5%细胞中表达
  small.mat=round(small.mat)
  small.mat=as.data.frame(t(small.mat))
  write.table(small.mat,file = paste(pi,".count.txt",sep = ""),quote = F,sep = "\t",row.names = T,col.names = T)
}

####第1步Python
cd /home/dell/singlecell/nmf/
source NMF-genek/bin/activate
cd /home/dell/singlecell/oral/



export HDF5_USE_FILE_LOCKING="FALSE"

python cNMF/cnmf.py prepare --output-dir ./CNMF1/ --name es1_cNMF -c es1_m.txt -k 3 4 5 6 7 8 9 10 --n-iter 300 --total-workers 8 --numgenes 2000
python cNMF/cnmf.py factorize --output-dir ./CNMF1/ --name es1_cNMF
python cNMF/cnmf.py combine --output-dir ./CNMF1/ --name es1_cNMF
python cNMF/cnmf.py k_selection_plot --output-dir ./CNMF1/ --name es1_cNMF

python cNMF/cnmf.py prepare --output-dir ./CNMF1/ --name tpd1_cNMF -c tpd1_m.txt -k 3 4 5 6 7 8 9 10 --n-iter 300 --total-workers 7 --numgenes 2000
python cNMF/cnmf.py factorize --output-dir ./CNMF1/ --name tpd1_cNMF
python cNMF/cnmf.py combine --output-dir ./CNMF1/ --name tpd1_cNMF
python cNMF/cnmf.py k_selection_plot --output-dir ./CNMF1/ --name tpd1_cNMF


python cNMF/cnmf.py prepare --output-dir ./CNMF1/ --name tpd2_cNMF -c tpd2_m.txt -k 3 4 5 6 7 8 9 10 --n-iter 300 --total-workers 7 --numgenes 2000
python cNMF/cnmf.py factorize --output-dir ./CNMF1/ --name tpd2_cNMF
python cNMF/cnmf.py combine --output-dir ./CNMF1/ --name tpd2_cNMF
python cNMF/cnmf.py k_selection_plot --output-dir ./CNMF1/ --name tpd2_cNMF

python cNMF/cnmf.py prepare --output-dir ./CNMF1/ --name tpd3_cNMF -c tpd3_m.txt -k 3 4 5 6 7 8 9 10 --n-iter 300 --total-workers 7 --numgenes 2000
python cNMF/cnmf.py factorize --output-dir ./CNMF1/ --name tpd3_cNMF
python cNMF/cnmf.py combine --output-dir ./CNMF1/ --name tpd3_cNMF
python cNMF/cnmf.py k_selection_plot --output-dir ./CNMF1/ --name tpd3_cNMF

python cNMF/cnmf.py prepare --output-dir ./CNMF1/ --name tpd4_cNMF -c tpd4_m.txt -k 3 4 5 6 7 8 9 10 --n-iter 300 --total-workers 7 --numgenes 2000
python cNMF/cnmf.py factorize --output-dir ./CNMF1/ --name tpd4_cNMF
python cNMF/cnmf.py combine --output-dir ./CNMF1/ --name tpd4_cNMF
python cNMF/cnmf.py k_selection_plot --output-dir ./CNMF1/ --name tpd4_cNMF

python cNMF/cnmf.py prepare --output-dir ./CNMF1/ --name tpd5_cNMF -c tpd5_m.txt -k 3 4 5 6 7 8 9 10 --n-iter 300 --total-workers 7 --numgenes 2000
python cNMF/cnmf.py factorize --output-dir ./CNMF1/ --name tpd5_cNMF
python cNMF/cnmf.py combine --output-dir ./CNMF1/ --name tpd5_cNMF
python cNMF/cnmf.py k_selection_plot --output-dir ./CNMF1/ --name tpd5_cNMF



#选K
#5
python cNMF/cnmf.py consensus --output-dir ./CNMF1/ --name es1_cNMF --components 6 --local-density-threshold 2 --show-clustering
python cNMF/cnmf.py consensus --output-dir ./CNMF1/ --name es1_cNMF --components 6 --local-density-threshold 0.01 --show-clustering
#6
python cNMF/cnmf.py consensus --output-dir ./CNMF1/ --name tpd1_cNMF --components 8 --local-density-threshold 2 --show-clustering
python cNMF/cnmf.py consensus --output-dir ./CNMF1/ --name tpd1_cNMF --components 8 --local-density-threshold 0.02 --show-clustering
python cNMF/cnmf.py consensus --output-dir ./CNMF1/ --name tpd1_cNMF --components 8 --local-density-threshold 0.01 --show-clustering
#16
python cNMF/cnmf.py consensus --output-dir ./CNMF1/ --name tpd2_cNMF --components 8 --local-density-threshold 2 --show-clustering
python cNMF/cnmf.py consensus --output-dir ./CNMF1/ --name tpd2_cNMF --components 8 --local-density-threshold 0.02 --show-clustering
python cNMF/cnmf.py consensus --output-dir ./CNMF1/ --name tpd2_cNMF --components 8 --local-density-threshold 0.01 --show-clustering
#17
python cNMF/cnmf.py consensus --output-dir ./CNMF1/ --name tpd3_cNMF --components 5 --local-density-threshold 2 --show-clustering
python cNMF/cnmf.py consensus --output-dir ./CNMF1/ --name tpd3_cNMF --components 5 --local-density-threshold 0.02 --show-clustering
python cNMF/cnmf.py consensus --output-dir ./CNMF1/ --name tpd3_cNMF --components 5 --local-density-threshold 0.01 --show-clustering
#18
python cNMF/cnmf.py consensus --output-dir ./CNMF1/ --name tpd4_cNMF --components 6 --local-density-threshold 2 --show-clustering
python cNMF/cnmf.py consensus --output-dir ./CNMF1/ --name tpd4_cNMF --components 6 --local-density-threshold 0.02 --show-clustering
python cNMF/cnmf.py consensus --output-dir ./CNMF1/ --name tpd4_cNMF --components 6 --local-density-threshold 0.01 --show-clustering
#20
python cNMF/cnmf.py consensus --output-dir ./CNMF1/ --name tpd5_cNMF --components 6 --local-density-threshold 2 --show-clustering
python cNMF/cnmf.py consensus --output-dir ./CNMF1/ --name tpd5_cNMF --components 6 --local-density-threshold 0.02 --show-clustering
python cNMF/cnmf.py consensus --output-dir ./CNMF1/ --name tpd5_cNMF --components 6 --local-density-threshold 0.01 --show-clustering

####第一步R 1.qc.R，对跑完cNMF矩阵后进行质控

singularity shell /home/dell/soft/scRNA_20220525.sif
library(tidyverse)
library(future)
plan("multiprocess",workers=20)
###future.globals.maxSize= X,x的单位是字节，下面这句代码是8个G
options(future.globals.maxSize= 8000*1024^2) 
library(data.table)
library(Seurat)
library(tidyverse)
library(dplyr)
library(patchwork)
#install.packages("devtools")
#library(devtools)
#install_github("immunogenomics/harmony")
library(harmony)
#BiocManager::install("SingleCellExperiment")
library(SingleCellExperiment)
set.seed(123456)


for (pi in c("es1", "tpd1", "tpd2", "tpd3", "tpd4", "tpd5")) {
  usage.file=dir("./3.important_result/",pattern = paste(pi,"_cNMF.usages",sep = ""))
  usage.df=read.table(paste("./3.important_result/",usage.file,sep = ""),header = T,row.names = 1,sep = "\t",stringsAsFactors = F)
  colnames(usage.df)=paste(pi,1:dim(usage.df)[2],sep = "_")
  #normalize
  usage.df=usage.df / rowSums(usage.df)
  write.table(usage.df,file = paste(pi,"program.usage.norm.txt",sep = "_"),quote = F,sep = "\t",row.names = T,col.names = T)
  #QC1
  tmpdf1=gather(usage.df,"program","ratio")
  tmpdf1%>%ggplot(aes(x=program,y=ratio))+geom_boxplot(outlier.shape = NA)+geom_jitter(color="red",alpha=0.4)
  ggsave(paste(pi,"program.usage.norm.QC.png",sep = "_"),device = "png",width = 20,height = 16,units = c("cm"))
  #score
  score.file=dir("./3.important_result/",pattern = paste(pi,"_cNMF.gene_spectra_score",sep = ""))
  score.df=read.table(paste("./3.important_result/",score.file,sep = ""),header = T,row.names = 1,sep = "\t",stringsAsFactors = F)
  score.df=as.data.frame(t(score.df))
  colnames(score.df)=paste(pi,1:dim(score.df)[2],sep = "_")
  
  top20.df=as.data.frame(matrix(nrow = 20,ncol = ncol(score.df)))
  colnames(top20.df)=colnames(score.df)
  for (k in colnames(score.df)) {
    tmpv=score.df[,k]
    names(tmpv)=rownames(score.df)
    top20.df[,k]=names(rev(tail(sort(tmpv),20)))
  }
  write.table(top20.df,file = paste(pi,"program.Zscore.top20gene.txt",sep = "_"),quote = F,sep = "\t",row.names = F,col.names = T)
  score.df$gene=rownames(score.df)
  write.table(score.df,file = paste(pi,"program.Zscore.txt",sep = "_"),quote = F,sep = "\t",row.names = F,col.names = T)
}
############################################################
check.usage=data.frame()
for (pi in c("es1", "tpd1", "tpd2", "tpd3", "tpd4", "tpd5")) {
  usage.file=paste(pi,"_program.usage.norm.txt",sep = "")
  usage.df=read.table(usage.file,header = T,row.names = 1,sep = "\t",stringsAsFactors = F)
  check.usage=rbind(check.usage,as.data.frame(colMeans(usage.df)))
}
colnames(check.usage)=c("mean_ratio")

check.usage$patient_programs=factor(rownames(check.usage),levels = rownames(check.usage))
check.usage%>%ggplot(aes(x=patient_programs,y=mean_ratio))+geom_point()+
  geom_hline(yintercept = 0.01,color="red")+ #这里的阈值，我之前做10X数据用的0.01，示例数据用的smart-seq2，稍微调大一点
  theme(
    axis.text.x.bottom = element_text(angle = 90,vjust = 0.5,hjust = 1)
  )
ggsave("check.usage.1.png",width = 30,height = 16,device = "png",units = "cm")

check.usage=check.usage%>%arrange(mean_ratio)
check.usage$patient_programs=as.character(check.usage$patient_programs)
check.usage$patient_programs=factor(check.usage$patient_programs,levels = check.usage$patient_programs)
check.usage%>%ggplot(aes(x=patient_programs,y=mean_ratio))+geom_point()+
  geom_hline(yintercept = 0.01,color="red")+
  geom_vline(xintercept = 3.5,color="red")+ #小于0.03有三个program，所以截距选的3.5
  theme(
    axis.text.x.bottom = element_text(angle = 90,vjust = 0.5,hjust = 1)
  )
ggsave("check.usage.2.png",width = 30,height = 16,device = "png",units = "cm")
#这两张图起辅助判断的作用，不画图直接卡阈值也可以
maybe.bg=as.character(check.usage$patient_programs[1:3])
#提取出可能是背景噪声的program
# "es1_5"  "tpd4_2" "tpd2_4"

####第二步R 2.cor_heatmap.R
library(tidyverse)
library(pheatmap)
library(RColorBrewer)
library(scales)

all.score.df=data.frame()
all.score.top20.df=data.frame()

for (pi in c("es1", "tpd1", "tpd2", "tpd3", "tpd4", "tpd5")) {
  score.file=paste("./4.after_qc/",pi,"_program.Zscore.txt",sep = "")
  score.df=read.table(score.file,header = T,sep = "\t",stringsAsFactors = F)
  if (pi=="es1") {all.score.df=score.df}
  if (pi!="es1") {
    all.score.df=all.score.df%>%inner_join(score.df,by="gene")
  }
  
  score.top20.file=paste("./4.after_qc/",pi,"_program.Zscore.top20gene.txt",sep = "")
  score.top20.df=read.table(score.top20.file,header = T,sep = "\t",stringsAsFactors = F)
  if (pi=="es1") {all.score.top20.df=score.top20.df}
  if (pi!="es1") {
    all.score.top20.df=cbind(all.score.top20.df,score.top20.df)
  }
}

rownames(all.score.df)=all.score.df$gene
all.score.df$gene=NULL
#可能有空值，需要去掉
all.score.df=all.score.df[rowSums(is.na(all.score.df)) == 0,]
all.score.rm.df=all.score.df[,setdiff(colnames(all.score.df),c("es1_5", "tpd4_2", "tpd2_4"))] #在质控这一步检测出来的噪声
all.score.rm.df.cor=cor(all.score.rm.df,method = "pearson")

all.score.rm.df.cor[all.score.rm.df.cor < 0]=0 #这一步也可以不要
all.score.rm.df.cor[all.score.rm.df.cor > 0.6]=0.6 #这一步因为原文用的是0.6，所以我这里也限制最大相关系数为0.6，主要是为了图明显一些。此前用的10X数据，相关系数比较高，所以没有限制

colanno=as.data.frame(colnames(all.score.rm.df.cor))
colnames(colanno)="colnames"
colanno$patient=str_replace(colanno$colnames,"_.*","")
rownames(colanno)=colanno$colnames
colanno$colnames=NULL

rowanno=as.data.frame(rownames(all.score.rm.df.cor))
colnames(rowanno)="rownames"
rowanno$patient=str_replace(rowanno$rownames,"_.*","")
rownames(rowanno)=rowanno$rownames
rowanno$rownames=NULL

#指定注释条的颜色
color_v=brewer.pal(6, "Set3")
names(color_v)=c("es1", "tpd1", "tpd2", "tpd3", "tpd4", "tpd5")
ann_colors = list(patient = color_v)

pheatmap(all.score.rm.df.cor,cluster_rows = T,cluster_cols = T,
         clustering_method = "ward.D2", #聚类方法可以调整
         show_colnames = F,
         treeheight_row=30,treeheight_col=0,
         border_color=NA,
         annotation_row = rowanno,annotation_col = colanno,
         annotation_names_row = F,annotation_names_col = F,
         annotation_colors = ann_colors,
         color = colorRampPalette(c("white","yellow", "red","#67001F"))(50),
         fontsize_row=12,
         width = 11.5,height = 9,
         filename = 'program_pearson_cor.ward.D2.heatmap.pdf'
)

all.score.top20.rm.df=all.score.top20.df[,setdiff(colnames(all.score.top20.df),c("es1_5", "tpd4_2", "tpd2_4"))]#在质控这一步检测出来的噪声
write.table(all.score.top20.rm.df,file = "program_top20gene.txt",quote = F,sep = "\t",row.names = F,col.names = T)

#实际分析中的一些经验
#相关性聚类这一步需要多做几次。根据每个program的大致功能，如果发现另一种功能的program聚到某一种meta模块里面，这时可以将乱入的program删掉，再做一次相关性聚类。
#如果我们认定应该属于同一个meta模块的program分散在两个地方，可以试试调整聚类方法(参数clustering_method)，或者像"_1""_2"这样定义

####第三步R，富集 3.enrich.R
library(clusterProfiler)
library(org.Hs.eg.db)
library(ggplot2)
library(tidyverse)
#library(xlsx)
library(msigdbr)
library(GSVA)
library(tidyverse)
library(clusterProfiler)
library(patchwork)
library(fgsea)
library(dplyr)
library(ggplot2)

#选择和肿瘤相关的基因集
hsets <- read.gmt("c7.all.v7.5.1.symbols.gmt")
enrich.result=data.frame()

program_top20=read.table("program_top20gene.txt",header = T,sep = "\t",stringsAsFactors = F)
for (i in 1:dim(program_top20)[2]) {
  tmp <- enricher(program_top20[,i], TERM2GENE = hsets)
  if (is.null(tmp)) {
    next
  }
  tmp_result <- tmp@result
  tmp1=head(tmp_result)
  tmp1$program=colnames(program_top20)[i]
  rownames(tmp1)=NULL
  enrich.result=rbind(enrich.result,tmp1)
}
write.table(enrich.result,file = "program_top20gene_anno.txt",sep="\t",quote=F,row.names = F)

###第四步R 单个样本  4.one_sample_heatmap.R

library(tidyverse)
library(pheatmap)
library(RColorBrewer)

P28_count=read.table("HNSCC28.count.txt",header = T,row.names = 1,sep = "\t",stringsAsFactors = F)
P28_count=as.data.frame(t(P28_count))

plot_gene=read.table("program_top20gene.txt",header = T,sep = "\t",stringsAsFactors = F)
plot_gene=plot_gene[,str_detect(colnames(plot_gene),"HNSCC28")]
plot_gene=c(plot_gene[,1],plot_gene[,2],plot_gene[,3],plot_gene[,4])
P28_count=P28_count[plot_gene,]
P28_count=t(scale(t(P28_count)))

P28_count[P28_count< (-2)] = -2
P28_count[P28_count >2]=2

pheatmap(P28_count,cluster_rows = F,cluster_cols = T,
         color = colorRampPalette(rev(brewer.pal(n = 9, name = "RdBu")))(100),
         treeheight_col=0,
         clustering_method = "complete", #"average" "ward.D" "complete"
         show_colnames=F,
         border_color=NA,
         gaps_row=c(20,40,60),
         fontsize_row=9.5,
         width = 10,height = 9,
         filename = 'HNSCC28_program_.138cell.complete.heatmap.pdf'
)





###################################写cNMF
#es1
es1_m<-subset(scRNA_harmony,orig.ident=="es1" & (singleRnew=="B_cell" | singleRnew=="Mast_cell" | singleRnew=="Monocyte" | singleRnew=="NK_cell" | singleRnew=="Neutrophils" | singleRnew=="T_cells" ))
es1_m_count<-es1_m@assays$RNA@counts
es1_m_count<-t(es1_m_count)
write.table(es1_m_count,file="es1_m.txt",quote=F,row.names=T,col.names=T,sep="\t")
#tpd1
tpd1_m<-subset(scRNA_harmony,orig.ident=="tpd1" & (singleRnew=="B_cell" | singleRnew=="Mast_cell" | singleRnew=="Monocyte" | singleRnew=="NK_cell" | singleRnew=="Neutrophils" | singleRnew=="T_cells" ))
tpd1_m_count<-tpd1_m@assays$RNA@counts
tpd1_m_count<-t(tpd1_m_count)
write.table(tpd1_m_count,file="tpd1_m.txt",quote=F,row.names=T,col.names=T,sep="\t")
#tpd2
tpd2_m<-subset(scRNA_harmony,orig.ident=="tpd2" & (singleRnew=="B_cell" | singleRnew=="Mast_cell" | singleRnew=="Monocyte" | singleRnew=="NK_cell" | singleRnew=="Neutrophils" | singleRnew=="T_cells" ))
tpd2_m_count<-tpd2_m@assays$RNA@counts
tpd2_m_count<-t(tpd2_m_count)
write.table(tpd2_m_count,file="tpd2_m.txt",quote=F,row.names=T,col.names=T,sep="\t")

#tpd3
tpd3_m<-subset(scRNA_harmony,orig.ident=="tpd3" & (singleRnew=="B_cell" | singleRnew=="Mast_cell" | singleRnew=="Monocyte" | singleRnew=="NK_cell" | singleRnew=="Neutrophils" | singleRnew=="T_cells" ))
tpd3_m_count<-tpd3_m@assays$RNA@counts
tpd3_m_count<-t(tpd3_m_count)
write.table(tpd3_m_count,file="tpd3_m.txt",quote=F,row.names=T,col.names=T,sep="\t")

#tpd4
tpd4_m<-subset(scRNA_harmony,orig.ident=="tpd4" & (singleRnew=="B_cell" | singleRnew=="Mast_cell" | singleRnew=="Monocyte" | singleRnew=="NK_cell" | singleRnew=="Neutrophils" | singleRnew=="T_cells" ))
tpd4_m_count<-tpd4_m@assays$RNA@counts
tpd4_m_count<-t(tpd4_m_count)
write.table(tpd4_m_count,file="tpd4_m.txt",quote=F,row.names=T,col.names=T,sep="\t")

#tpd5
tpd5_m<-subset(scRNA_harmony,orig.ident=="tpd5" & (singleRnew=="B_cell" | singleRnew=="Mast_cell" | singleRnew=="Monocyte" | singleRnew=="NK_cell" | singleRnew=="Neutrophils" | singleRnew=="T_cells" ))
tpd5_m_count<-tpd5_m@assays$RNA@counts
tpd5_m_count<-t(tpd5_m_count)
write.table(tpd5_m_count,file="tpd5_m.txt",quote=F,row.names=T,col.names=T,sep="\t")

#######################################################14scGENA----跑不出来，会报错
load("20221012.RData")

library(Seurat)
library(sctransform)
library(ggthemes)
library(dplyr)
library(ggplot2)
library(GGally)
library(GSEABase)
library(limma)
library(reshape2)
library(knitr)
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
library(stringr)
library(NMF)
library(rsvd)
library(data.table)
library(RColorBrewer)
library(MAST)
library(cowplot)
library(patchwork)
library(limma)
library(Biobase)
library(marray)
library(convert)
library(Matrix)
if (!dir.exists("14scGENA")){
dir.create("14scGENA")
}

setwd("./14scGENA")#切换工作目录


#we use seurat for preprocessing analysis

## Initialize the Seurat object with the raw (non-normalized data).
xinseurat <- subset(scRNA_harmony,singleRnew=="Neutrophils")
  # 29043  1492
levels(xinseurat)    # sample



# The [[ operator can add columns to object metadata. This is a great place to stash QC stats
#FFFFFF

#data normalization
#normalized data are saved in [RNA]@data

xinseurat <- NormalizeData(xinseurat)

# xinseurat <- NormalizeData(xinseurat, normalization.method = "LogNormalize", scale.factor = 10000)

# Identification of highly variable features (feature selection)
xinseurat <- FindVariableFeatures(xinseurat, selection.method = "vst", nfeatures = 2000)


# Identify the 10 most highly variable genes
top10 <- head(VariableFeatures(xinseurat), 10)
top10

# plot variable features with and without labels
pdf(file = "figures_top10 variable features.pdf", wi = 12, he = 6)
# tiff("figures_variable features.tiff", units="in", width=12, height=6, res=300)

plot1 <- VariableFeaturePlot(xinseurat)
plot2 <- LabelPoints(plot = plot1, points = top10)
plot1 + plot2
dev.off()


## data scaling 
# The results of this are stored in pbmc[["RNA"]]@scale.data
all.genes <- rownames(xinseurat)
xinseurat <- ScaleData(xinseurat, features = all.genes)
head(xinseurat[["RNA"]]@scale.data,5)
dim(xinseurat)  #29043 1472
levels(xinseurat)


## Perform dimensional reduction
xinseurat <- RunPCA(xinseurat, features = VariableFeatures(object = xinseurat))
# Examine and visualize PCA results a few different ways
#print(xinseurat[["pca"]], dims = 1:5, nfeatures = 5)

pdf(file = "figures_PCA linear dimensional reduction.pdf", wi = 12, he = 8)
# tiff("figures/Dim reduction.tiff", units="in", width=12, height=8, res=300)
VizDimLoadings(xinseurat, dims = 1:2, reduction = "pca")
dev.off()

pdf(file = "figures_dimplot.pdf", wi = 12, he = 5)
# tiff("figures/dimplot.tiff", units="in", width=12, height=5, res=300)
DimPlot(xinseurat, reduction = "pca")
dev.off()

pdf(file = "figures_dimheatmap.pdf", wi = 10, he = 6)
# tiff("figures/dimheatmap.tiff", units="in", width=10, height=6, res=300)
DimHeatmap(xinseurat, dims = 1, cells = 500, balanced = TRUE)
dev.off()

pdf(file = "figures_dimheatmap 9.pdf", wi = 10, he = 6)
# tiff("figures/dimheatmap 9.tiff", units="in", width=10, height=6, res=300)
DimHeatmap(xinseurat, dims = 1:9, cells = 500, balanced = TRUE)
dev.off()





## Cluster the cells
xinseurat <- FindNeighbors(xinseurat, dims = 1:10)
xinseurat <- FindClusters(xinseurat, resolution = 0.3)  # resolution to incr/dec No. of clusters
## Look at cluster IDs of the first 5 cells
head(Idents(xinseurat), 5)
levels(xinseurat)  #



#UMAP
# xinseurat <- RunUMAP(xinseurat, dims = 1:10, verbose = F)
# tiff("figures/clusters UMAP.tiff", units="in", width=9, height=5, res=300)

xinseurat <- RunUMAP(xinseurat, dims = 1:10)
pdf("figures_clusters UMAP.pdf", width=9, height=5)
DimPlot(xinseurat, reduction = "umap")
dev.off()


#tsne
# tiff("figures/tSNE plot clusters.tiff", units="in", width=9, height=5, res=300)

xinseurat <- RunTSNE(xinseurat, dims = 1:10)
pdf("figures_tSNE plot clusters.pdf", width=9, height=5)
DimPlot(xinseurat, reduction = "tsne")
DimPlot(xinseurat, reduction = "tsne", label = TRUE)
dev.off()
# note that you can set `label = TRUE` or use the LabelClusters function to help label
# individual clusters

save(xinseurat, file = "seurat_object_of_Xin_Data.RData")
xinseurat.markers <- FindAllMarkers(xinseurat, only.pos = TRUE, 
                                    min.pct = 0.15, 
                                    logfc.threshold = 0.15)
xinseurat.markers %>% group_by(cluster) %>% top_n(n = 1, wt = avg_log2FC)
dim(xinseurat.markers)    #2169    7

#identify top10 differentiated genes
top10 <- xinseurat.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_log2FC)

# Visualise several genes 
pdf("Visualise several genes.pdf")
VlnPlot(xinseurat, features = top10)

#VlnPlot(xinseurat, features = c("TTR", "INS", "TM4SF4", "PPY", "GCG", "RBP4", "IAPP", "FABP5","SPINK1"))

FeaturePlot(xinseurat, features = top10)

RidgePlot(xinseurat, features = top10)

DotPlot(xinseurat, features = top10)

DoHeatmap(xinseurat, features = top10$gene, label = TRUE)#+ NoLegend()

DoHeatmap(subset(xinseurat, downsample = 10), features = top10$gene, size = 3)
dev.off()

# Next step 5: DE genes
# Step 5: Gene co-expression network analysis
# we build a networks based on pseudo-bulk cell types

# packages
library(Seurat)
library(Matrix)
library(tidyverse)
library(rliger)
library(dplyr)

# library(scWGCNA)

# celltyps="alpha", "beta", "gamma", "delta"

#seurat_beta <- subset(xinse_meta, cell_type1 %in% c("beta"))
#dim(seurat_beta) #29043   460

#save(xinse_meta, file = "seurat_obj_with_metadata_celltypes.RData")


#seurat_mark <- FindAllMarkers(seurat_beta, only.pos = TRUE, 
                              min.pct = 0.25, 
                              logfc.threshold = 0.25)

genes_mark <- xinseurat.markers[,7]
beta_mat <- as.data.frame(as.matrix(xinseurat@assays[["RNA"]]@data))
sub_mar <- beta_mat[genes_mark,]

#Imputation method, skip if not necessary
library(SAVER)
Beta_saver <- saver(sub_mar, 
                    ncores = 12, 
                    estimates.only = TRUE)

save(Beta_saver, xinseurat.markers, file = "02beta_preprocessin_imp.RData")

#run GCNs

library(tidyverse)
library(WGCNA)
library(flashClust)
enableWGCNAThreads()


datExpr <- as.data.frame(t(Beta_saver))
# 
# # only keep good genes:
datTraits <- datExpr[,goodGenes(datExpr)]
save(datExpr, datTraits, file = "03Beta_datExpre.RData")

#load("Beta_datExpre.RData")


# # Choose a set of soft-thresholding powers
powers = c(seq(1,10,by=1), seq(12,20, by=2));

# # Call the network topology analysis function for each set in turn
powerTable = list(
  data = pickSoftThreshold(
    datExpr,
    powerVector=powers,
    verbose = 100,
    networkType="signed",
    corFnc="bicor"
  )[[2]]
)

# Plot the results:
pdf("03figures_Beta_softPower.pdf", height=10, width=18)

colors = c("blue", "red","black")
# Will plot these columns of the returned scale free analysis tables
plotCols = c(2,5,6,7)
colNames = c("Scale Free Topology Model Fit", "Mean connectivity", "mean connectivity",
             "Max connectivity");

# Get the minima and maxima of the plotted points
ylim = matrix(NA, nrow = 2, ncol = 4);
for (col in 1:length(plotCols)){
  ylim[1, col] = min(ylim[1, col], powerTable$data[, plotCols[col]], na.rm = TRUE);
  ylim[2, col] = max(ylim[2, col], powerTable$data[, plotCols[col]], na.rm = TRUE);
}

# Plot the quantities in the chosen columns vs. the soft thresholding power
par(mfcol = c(2,2));
par(mar = c(4.2, 4.2 , 2.2, 0.5))
cex1 = 0.7;

for (col in 1:length(plotCols)){
  plot(powerTable$data[,1], -sign(powerTable$data[,3])*powerTable$data[,2],
       xlab="Soft Threshold (power)",ylab=colNames[col],type="n", ylim = ylim[, col],
       main = colNames[col]);
  addGrid();

  if (col==1){
    text(powerTable$data[,1], -sign(powerTable$data[,3])*powerTable$data[,2],
         labels=powers,cex=cex1,col=colors[1]);
  } else
    text(powerTable$data[,1], powerTable$data[,plotCols[col]],
         labels=powers,cex=cex1,col=colors[1]);
  if (col==1){
    legend("bottomright", legend = 'Betacells', col = colors, pch = 20) ;
  } else
    legend("topright", legend = 'Betacells', col = colors, pch = 20) ;
}
dev.off()

# Based on the soft power threshold that you have selected, now we can build the co-expression network. Consult the WGCNA documentation if you need help selecting a soft power value. Furthermore, you should read the function description for blockwiseConsensusModules carefully to select the different parameters, however the ones that I have chosen here have generally given good results on a variety of datasets.



softPower=6

nSets = 1
setLabels = 'beta'
shortLabels = setLabels

multiExpr <- list()
multiExpr[['beta']] <- list(data=datExpr)

checkSets(multiExpr) # check data size


# construct network
net=blockwiseConsensusModules(multiExpr, blocks = NULL,
                              maxBlockSize = 1000, ## This should be set to a smaller size if the user has limited RAM
                              randomSeed = 12345,
                              corType = "bicor", # "bicor"bidweight mid correlation
                              power = softPower,
                              consensusQuantile = 0.1,
                              networkType = "signed",
                              TOMType = "unsigned",
                              TOMDenom = "min",
                              scaleTOMs = TRUE, scaleQuantile = 0.8,
                              sampleForScaling = TRUE, sampleForScalingFactor = 1000,
                              useDiskCache = TRUE, chunkSize = NULL,
                              deepSplit = 4,
                              pamStage=FALSE,
                              detectCutHeight = 0.995, minModuleSize = 40,
                              mergeCutHeight = 0.2,
                              saveConsensusTOMs = TRUE,
                              consensusTOMFilePattern = "ConsensusTOM-block.%b.rda")



consMEs = net$multiMEs;
moduleLabels = net$colors;

# Convert the numeric labels to color labels
moduleColors = as.character(moduleLabels)
consTree = net$dendrograms[[1]];

# module eigengenes
MEs=moduleEigengenes(multiExpr[[1]]$data, colors = moduleColors, nPC=1)$eigengenes
MEs=orderMEs(MEs)
meInfo<-data.frame(rownames(datExpr), MEs)
colnames(meInfo)[1]= "SampleID"
# View(moduleColors)
# intramodular connectivity
KMEs<-signedKME(datExpr, MEs,outputColumnName = "kME",corFnc = "bicor")

# compile into a module metadata table
geneInfo=as.data.frame(cbind(colnames(datExpr),moduleColors, KMEs))

# how many modules did we get?
nmodules <- length(unique(moduleColors))

# merged gene symbol column
colnames(geneInfo)[1]= "GeneSymbol"
colnames(geneInfo)[2]= "Initially.Assigned.Module.Color"

# save info
write.csv(geneInfo,file=paste0('output_geneInfoSigned.csv'))
# write.csv(TOM.matrix,file=paste0('output/TOM_matrix.csv'))
# TOM_1 <- as.data.frame(consTomDS)
# write.csv(as.data.frame(consTomDS),file=paste0('output/Tom_cons.csv'))

PCvalues=MEs


pdf("figures_SignedDendro.pdf",height=5, width=8)
plotDendroAndColors(consTree, moduleColors, "Module colors", dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05,
                    main = paste0("Beta lineage gene dendrogram and module colors"))
dev.off()


library(igraph)
library(RColorBrewer)

load("ConsensusTOM-block.1.rda")

TOM.matrix = as.matrix(consTomDS);
uniquemodcolors = unique(geneInfo$Initially.Assigned.Module.Color);
# uniquemodcolors=uniquemodcolors[uniquemodcolors!= 'blue']


pdf(paste0('figures_Beta ModuleNetworks_4.pdf'),height=9,width=10)
# tiff("figures/dimplot.tiff", units="in", width=12, height=9, res=300)

for (mod in uniquemodcolors)  {
  numgenesingraph = 25;
  numconnections2keep = 500;
  cat('module:',mod,'\n');
  geneInfo=geneInfo[geneInfo$GeneSymbol!="NA",]
  colind = which(colnames(geneInfo)==paste('kME',mod,sep=''));
  rowind = which(geneInfo$Initially.Assigned.Module.Color==mod);
  cat(' ',length(rowind),'probes in module\n');
  submatrix = geneInfo[rowind,];
  orderind = order(submatrix[,colind],decreasing=TRUE);
  if (length(rowind) < numgenesingraph) {
    numgenesingraph = length(rowind);
    numconnections2keep = numgenesingraph * (numgenesingraph - 1);
  }
  cat('Making network graphs, using top',numgenesingraph,'probes and',numconnections2keep,'connections of TOM\n');
  submatrix = submatrix[orderind[1:numgenesingraph],];
  matchind = match(submatrix$GeneSymbol,colnames(datExpr));
  reducedTOM = TOM.matrix[matchind,matchind];
  
  orderind = order(reducedTOM,decreasing=TRUE);
  connections2keep = orderind[1:numconnections2keep];
  reducedTOM = matrix(0,nrow(reducedTOM),ncol(reducedTOM));
  reducedTOM[connections2keep] = 1;
  
  gA <- graph.adjacency(as.matrix(reducedTOM[1:10,1:10]),mode="undirected",weighted=TRUE,diag=FALSE)
  gB <- graph.adjacency(as.matrix(reducedTOM[11:25,11:25]),mode="undirected",weighted=TRUE,diag=FALSE)
  layoutCircle <- rbind(layout.circle(gA)/2,layout.circle(gB))
  
  g1 <- graph.adjacency(as.matrix(reducedTOM),mode="undirected",weighted=TRUE,diag=FALSE)
  
  plot(g1,
       edge.color=adjustcolor(mod, alpha.f=0.25),
       edge.alpha=0.25,
       vertex.color=adjustcolor(mod, alpha.f=0.75),
       vertex.label=as.character(submatrix$GeneSymbol),
       vertex.label.cex=2.2,
       vertex.label.dist=1.1,
       vertex.label.degree=-pi/4,
       vertex.label.color="black",
       #vertex.frame.color='black',
       layout= jitter(layoutCircle),
       vertex.size=6,
       main=paste(mod,"module")
  )
}
dev.off()

save(multiExpr, softPower, nSets, setLabels, shortLabels, file = "Beta_multiExpre_Network.RData")
write.csv(reducedTOM,file=paste0('output_reduced_matrix.csv'))

#plotting a network heatmap
dissTOM = 1-TOMsimilarityFromExpr(datExpr, power = 8);
# # Transform dissTOM with a power to make moderately strong connections more visible in the heatmap
plotTOM = dissTOM^7;
# # Set diagonal to NA for a nicer plot
diag(plotTOM) = NA;
# # Call the plot function
geneTree = flashClust(as.dist(dissTOM), method="average")
# 
pdf("figures_network heatmap.pdf", width=12, height=9)
TOMplot(plotTOM, geneTree, moduleColors, main = "Network heatmap plot, Beta genes")
dev.off()


# # next: further analysis
